# 148. Sort List

## question

Given the `head` of a linked list, return *the list after sorting it in **ascending order***.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

```
Input: head = [4,2,1,3]
Output: [1,2,3,4]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

```
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
```

**Example 3:**

```
Input: head = []
Output: []
```

 

**Constraints:**

- The number of nodes in the list is in the range `[0, 5 * 104]`.
- `-105 <= Node.val <= 105`

 

**Follow up:** Can you sort the linked list in `O(n logn)` time and `O(1)` memory (i.e. constant space)?



## solution

虽说是暴力解，但是似乎从结果上来看时间空间复杂度都非常好。我可以理解我时间复杂度好的原因在于sort库函数的强大，但是我不理解为什么我引入了额外的vector数组后依然可以保持很好的空间复杂度。本体绝对有O（1）空间复杂度的解法，希望你认真学习

~~~
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode* curr = head;
        vector<int> result;
        while(curr)
        {
            result.push_back(curr->val);
            curr = curr->next;
        }
        sort(result.begin(),result.end());
        curr = head;
        int count = 0;
        while(curr)
        {
            curr->val = result[count];
            count++;
            curr = curr->next;
        }
        return head;
    }
};
~~~

