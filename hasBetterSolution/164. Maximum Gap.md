# 164. Maximum Gap

## question

Given an integer array `nums`, return *the maximum difference between two successive elements in its sorted form*. If the array contains less than two elements, return `0`.

You must write an algorithm that runs in linear time and uses linear extra space.

 

**Example 1:**

```
Input: nums = [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.
```

**Example 2:**

```
Input: nums = [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 109`



## solution

回家等通知法

~~~
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int result = 0;
        for(int i=1;i<nums.size();i++)
        {
            result = max(nums[i]-nums[i-1],result);
        }
        return result;
    }
};
~~~

基数排序，力扣官方题解中提到，基数排序相较于传统的快速排序和归并排序O(nlogn)，可以做到O(N)时间复杂度？但是实际上来看，理论上复杂度是基数排序更低，但nums数组规模达不到一定程度的情况下，很难说就完全比sort更好。

基数排序的效率高度依赖于最大位数 `d`。当 `d`较小且 `k`不大时，它可能接近线性 O(n)。

基数排序的时间复杂度是 **O(d \* (n + k))**，其中 `n`是待排序元素个数，`d`是最大数字的位数（或字符串的最大长度），`k`是每一位可能的取值范围（例如十进制数字就是0-9，所以 `k=10`）

如下解是使用通用radix sort模板加上自己一点点补充。

似乎这种方法并不能在实际应用层面上优于STL sort，根本还是在于，nums数组的元素个数并不会趋近于无穷大，并且快速排序的算法实现非常高效，logn本身也不会大到哪里去。而基数排序涉及计算位数，分桶，计数合并，导致其虽然看似是近似O(n)的算法（因为vector<int>中的int有位数上限，可视为常数），但是他的常数因子太大了导致在n较小时根本不能忽视。这也是为什么跑测试的时候sort在时间复杂度上反而优于基数排序。本题有点为了这碟醋包饺子的感觉了。因为题目本身要求使用时间复杂度O(n)的算法，所以使用了基数排序这种“理论O(n)”解来满足题目需求。但从实际应用角度上来看有点为赋新词强说愁了。

你应当从这次实践学到什么？学到基数排序是一种理论上的O(n)算法。当你绕不开排序又要求理论O(n)时要知道有基数排序这种东西的存在。

~~~
class Solution {
public:
    // 使用计数排序作为子程序，对特定位进行排序
    void countingSortForRadix(std::vector<int>& arr, long long exp) {
        int n = arr.size();
        std::vector<int> output(n); // 输出数组
        std::vector<int> count(10, 0); // 计数数组，初始化为0

        // 统计每个数字（0-9）出现的次数
        for (int i = 0; i < n; i++) {
            int digit = (arr[i] / exp) % 10;
            count[digit]++;
        }

        // 将count[i]变为小于等于i的元素个数（计算前缀和）
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        // 从后往前遍历原数组，保证稳定性
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }

        // 将排序好的output数组复制回原数组arr
        for (int i = 0; i < n; i++) {
            arr[i] = output[i];
        }
    }

    // 基数排序主函数
    void radixSort(std::vector<int>& arr) {
        if (arr.empty()) return;

        // 找到数组中的最大值，以确定最大位数
        int maxVal = *std::max_element(arr.begin(), arr.end());

        // 从最低位（个位）开始，依次对每一位进行计数排序
        for (long long exp = 1; maxVal / exp > 0; exp *= 10) {
            countingSortForRadix(arr, exp);
        }
    }
    int maximumGap(vector<int>& nums) {
        if(nums.size()<2) return 0;
        radixSort(nums);
        int result = INT_MIN;
        for(int i=1;i<nums.size();i++)
        {
            result = max(result,nums[i]-nums[i-1]);
        }
        return result;
    }
};
~~~

力扣官方题解

~~~
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        int n = nums.size();
        if(n<2) return 0;
        long long exp = 1;//位数
        vector<int> buf(n);//临时数组，用来存储排序结果最后copy给nums
        int maxVal = *max_element(nums.begin(),nums.end());
        //寻找数组中的最大值，用于确定基数排序中的位数上限
        while(maxVal>=exp)
        {
            //从最低位开始，对每一位实行基数排序
            vector<int> cnt(10);//使用十进制，因此使用空间为10的计数数组
            for(int i=0;i<n;i++)
            {
                //统计在当前exp位上，所有数字出现的次数
                int digit = (nums[i]/exp) % 10;
                cnt[digit]++;
            }

            for(int i=1;i<10;i++)
            {
                //将cnt[i]变为小于等于i的元素个数（计算前缀和）
                cnt[i] += cnt[i-1];
            }
            for(int i=n-1;i>=0;i--)
            {
                //从后往前遍历原数组，保证稳定性，如果不稳定，排完低位再拍高位会导致排序混乱
                int digit = (nums[i]/exp) % 10;
                buf[cnt[digit]-1] = nums[i];
                cnt[digit]--;
            }
            copy(buf.begin(),buf.end(),nums.begin());
            //更新exp位数，从低位到高位
            exp*=10;
        }

        int result = 0;
        for(int i=1;i<n;i++)
        {
            result = max(result,nums[i]-nums[i-1]);
        }
        return result;

    }
};
~~~

