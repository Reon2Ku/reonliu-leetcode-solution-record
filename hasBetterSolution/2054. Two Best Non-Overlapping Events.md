# 2054. Two Best Non-Overlapping Events

## question

You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose **at most** **two** **non-overlapping** events to attend such that the sum of their values is **maximized**.

Return *this **maximum** sum.*

Note that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/09/21/picture5.png)

```
Input: events = [[1,3,2],[4,5,2],[2,4,3]]
Output: 4
Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.
```

**Example 2:**

![Example 1 Diagram](https://assets.leetcode.com/uploads/2021/09/21/picture1.png)

```
Input: events = [[1,3,2],[4,5,2],[1,5,5]]
Output: 5
Explanation: Choose event 2 for a sum of 5.
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2021/09/21/picture3.png)

```
Input: events = [[1,5,3],[1,5,1],[6,6,5]]
Output: 8
Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.
```

 

**Constraints:**

- `2 <= events.length <= 105`
- `events[i].length == 3`
- `1 <= startTimei <= endTimei <= 109`
- `1 <= valuei <= 106`



## solution

第一版解，没注意到题目限制条件，要求最多只能参加两个活动。直接写成类背包问题了。此处仅做留档保存以免需要。

~~~
class Solution {
public:
    int maxTwoEvents(vector<vector<int>>& events) {
        sort(events.begin(),events.end(),[](const vector<int>& a,const vector<int>&b){
            return a[1]<b[1];
        }
        );
        for(vector<int> event:events)
        {
            cout<<event[0]<<" "<<event[1]<<" "<<event[2]<<endl;
        }
        vector<int> maxValue(events[0][1]+1,0);
        maxValue[events[0][1]] = events[0][2];
        for(vector<int> event:events)
        {
            if(event[1]+1>maxValue.size()) 
            {
                int temp = maxValue[maxValue.size()-1];
                maxValue.resize(event[1]+1,temp);
            }
            maxValue[event[1]] = max(maxValue[event[1]], maxValue[event[0]-1]+event[2]);
        }
        cout<<maxValue.size()<<endl;
        for(int i:maxValue) cout<<i<<endl;
        return maxValue[maxValue.size()-1];
    }
};
~~~

第二版解，超出内存限制了

~~~
class Solution {
public:
    int maxTwoEvents(vector<vector<int>>& events) {
        sort(events.begin(),events.end(),[](const vector<int>& a,const vector<int>&b){
            return a[1]<b[1];
        }
        );
        // for(vector<int> event:events)
        // {
        //     cout<<event[0]<<" "<<event[1]<<" "<<event[2]<<endl;
        // }
        vector<int> maxValue(events[0][1]+1,0);
        maxValue[events[0][1]] = events[0][2];
        int mymax = 0;
        for(vector<int> event:events)
        {
            maxValue.resize(event[1]+1,maxValue[maxValue.size()-1]);
            if(event[2]>maxValue[maxValue.size()-1]) maxValue[maxValue.size()-1]=event[2];
            mymax = max(mymax, maxValue[event[0]-1]+event[2]);
        }
        //for(int i:maxValue) cout<<i<<endl;
        return mymax;
    }
};
~~~

第三版解，超时了，至尊巅峰大圆满

~~~
class Solution {
public:
    int maxTwoEvents(vector<vector<int>>& events) {
        sort(events.begin(),events.end(),[](const vector<int>& a,const vector<int>&b){
            return a[1]<b[1];
        }
        );
        // for(vector<int> event:events)
        // {
        //     cout<<event[0]<<" "<<event[1]<<" "<<event[2]<<endl;
        // }
        vector<int> maxCompatible(events.size(),0);
        maxCompatible[0] = events[0][2];
        //cout<<maxCompatible[0]<<endl;
        for(int i=1;i<events.size();i++)
        {
            maxCompatible[i] = max(maxCompatible[i-1],events[i][2]);
            //cout<<maxCompatible[i]<<endl;
        }
        vector<int> maxIndex(events.size(),-1);
        for(int i=0;i<events.size();i++)
        {
            for(int j=i+1;j<events.size();j++)
            {
                if(events[i][1]<events[j][0]) maxIndex[j] = i;
            }
        }
        int mymax = 0;
        for(int i=0;i<events.size();i++)
        {
            if(maxIndex[i]==-1) mymax = max(mymax,events[i][2]);
            else 
            {
                mymax = max(mymax,maxCompatible[maxIndex[i]]+events[i][2]);
            }
        }

        return mymax;
    }
};
~~~

终于ac了，家人们真不容易啊

~~~
class Solution {
public:
    int maxTwoEvents(vector<vector<int>>& events) {
        vector<vector<int>> myevents(events);
        sort(events.begin(),events.end(),[](const vector<int>& a,const vector<int>&b){
            return a[1]<b[1];
        }
        );
        sort(myevents.begin(),myevents.end(),[](const vector<int>&a,const vector<int>&b){
            return a[0]<b[0];
        });
        // cout<<"end time sort"<<endl;
        // for(vector<int> event:events)
        // {
        //     cout<<event[0]<<" "<<event[1]<<" "<<event[2]<<endl;
        // }
        //cout<<events[0][2]<<endl;
        for(int i=1;i<events.size();i++)
        {
            events[i][2] = max(events[i][2],events[i-1][2]);
            //cout<<events[i][2]<<endl;
        }
        // cout<<"start time sort"<<endl;
        // for(vector<int> event:myevents)
        // {
        //     cout<<event[0]<<" "<<event[1]<<" "<<event[2]<<endl;
        // }
        int mymax = 0;
        int index = 0;
        for(int i=0;i<myevents.size();i++)
        {
            //cout<<"i="<<i<<endl;
            if(myevents[i][0]<=events[index][1]) mymax = max(mymax,myevents[i][2]);
            else
            {
                while(index<events.size()&&events[index][1]<myevents[i][0]) index++;
                index--;
                mymax = max(mymax,events[index][2]+myevents[i][2]);
            }
        }
        return mymax;
    }
};
~~~

