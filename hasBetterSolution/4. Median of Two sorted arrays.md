# 4. Median of Two sorted arrays

## description

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

 

**Example 1:**

```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

**Example 2:**

```
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

 

**Constraints:**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-106 <= nums1[i], nums2[i] <= 106`



## solution

暴力解：

然而这显然不是我们想看到的。暴力解能过全由于sort函数的强大

击败10%

时间复杂度(n+m)log(m+n)

~~~
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        nums1.insert(nums1.end(),nums2.begin(),nums2.end());
        sort(nums1.begin(),nums1.end());
        int size = nums1.size();
        if(size%2==0)
        {
            return (double)(nums1[size/2]+nums1[size/2-1])/2;
        }
        else return nums1[size/2];
    }
};
~~~

思路一，归并排序

时间复杂度m+n, 空间复杂度m+n

仅击败30%

~~~
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        //思路1 双指针归并排序
        int index1 = 0;
        int index2 = 0;
        vector<int> merge;
        while(index1<nums1.size() || index2<nums2.size())
        {
            if(index1>=nums1.size()&&index2<nums2.size())
            {
                merge.push_back(nums2[index2]);
                index2++;
            }
            else if(index2>=nums2.size())
            {
                merge.push_back(nums1[index1]);
                index1++;
            }
            else if(nums1[index1]<=nums2[index2])
            {
                merge.push_back(nums1[index1]);
                index1++;
            }
            else if(nums1[index1]>nums2[index2])
            {
                merge.push_back(nums2[index2]);
                index2++;
            }
        }
        if(merge.size()%2==1) return merge[merge.size()/2];
        else return (double)(merge[merge.size()/2]+merge[merge.size()/2-1])/2;
    }
};
~~~

思路二：因为只需要找中位数，所以只需要维护两个指针就行了，指针直到中位数后，直接返回

我懒得写了边界太麻烦了。时间复杂度m+n，空间复杂度1

思路三：二分查找

我跟leetcode现学现卖的，时间复杂度log(m+n)

~~~
~~~

