# 1150. Check if a number is majority element in a sorted array

## description

Given an integer array `nums` sorted in non-decreasing order and an integer `target`, return `true` *if* `target` *is a **majority** element, or* `false` *otherwise*.

A **majority** element in an array `nums` is an element that appears more than `nums.length / 2` times in the array.

 

**Example 1:**

```
Input: nums = [2,4,5,5,5,5,5,6,6], target = 5
Output: true
Explanation: The value 5 appears 5 times and the length of the array is 9.
Thus, 5 is a majority element because 5 > 9/2 is true.
```

**Example 2:**

```
Input: nums = [10,100,101,101], target = 101
Output: false
Explanation: The value 101 appears 2 times and the length of the array is 4.
Thus, 101 is not a majority element because 2 > 4/2 is false.
```

 

**Constraints:**

- `1 <= nums.length <= 1000`
- `1 <= nums[i], target <= 109`
- `nums` is sorted in non-decreasing order.



## solution

too easy

~~~
class Solution {
public:
    bool isMajorityElement(vector<int>& nums, int target) {
        //int half = nums.size()/2;
        int right = nums.size()-1;
        int left = 0;
        int index = -1;
        while(right>left)
        {
            int mid = (right+left)/2;
            if(nums[mid]>target) right = mid-1;
            else if(nums[mid]<target) left = mid+1;
            else if(nums[mid]==target) 
            {
                index = mid;
                break;
            }
        }
        if(index == -1) return false;
        int count = 1;
        int temp = index;
        //cout<<index<<endl;
        while(temp>0)
        {
            temp--;
            if(nums[temp]==target) 
            {
                //cout<<"when temp="<<temp<<"count++"<<endl;
                count++;
            }

            else break;
        }
        temp = index;
        while(temp<nums.size()-1)
        {
            temp++;
            if(nums[temp]==target) 
            {
                //cout<<"when temp="<<temp<<"count++"<<endl;
                count++;
            }
            else break;
        }
        //cout<<nums[index];
        //cout<<count<<endl;
        return count>nums.size()/2;
    }
};
~~~

看到一个比较吊的解法，虽然内存消耗爆了，哈哈

~~~
class Solution {
public:
    bool isMajorityElement(vector<int>& nums, int target) {
        auto left = lower_bound(nums.begin(),nums.end(),target);
        auto right = upper_bound(nums.begin(),nums.end(),target);
        return right-left > nums.size()/2;
    }
};
~~~

