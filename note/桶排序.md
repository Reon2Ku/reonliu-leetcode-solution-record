# 桶排序

~~~
#include <iostream>
#include <vector>
#include <algorithm> // 用于std::sort
using namespace std;

void bucketSort(std::vector<float> &arr) {
    if (arr.empty()) return;
    
    // 1. 初始化桶
    size_t n = arr.size();
    vector<vector<float>> buckets(n);
    
    // 2. 将数组元素放入对应的桶中
    for (float num : arr) {
        int bucketIndex = static_cast<int>(n * num); // 假设输入数据在[0,1)区间
        buckets[bucketIndex].push_back(num);
        //放入元素后的桶结构：
        //{
        	//{}
        	//{}
        	//{0.42,0.32,0.33,0.37}
        	//{0.52,0.47,0.51}
        	//{}
        	//{}
        	//{}
        //}
    }
    
    // 3. 对每个桶内部进行排序
    for (auto &bucket : buckets) {
        sort(bucket.begin(), bucket.end());
    }
    
    // 4. 按顺序将桶中元素合并回原数组
    int index = 0;
    for (const auto &bucket : buckets) {
        for (float num : bucket) {
            arr[index++] = num;
        }
    }
}

// 示例用法
int main() {
    vector<float> arr = {0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51};
    
    cout << "排序前: ";
    for (float num : arr) {
        cout << num << " ";
    }
    cout << std::endl;
    
    bucketSort(arr);
    
    cout << "排序后: ";
    for (float num : arr) {
        cout << num << " ";
    }
    cout << std::endl;
    
    return 0;
}
~~~

### 关键步骤解析

1. **创建空桶**：我们创建一个 `vector`的 `vector`，桶的数量通常等于待排序元素的个数。
2. **元素散列到桶中**：通过一个映射函数（此例为 `n * num`）计算每个元素应该放入哪个桶。目标是使数据均匀分布在各个桶中。
3. **排序非空桶**：使用一个高效的排序算法（如代码中的 `std::sort`）对每个非空桶进行排序。
4. **合并桶**：按桶的顺序（下标从0到n-1）依次取出桶中的元素，放回原数组。



桶排序的性能特点非常鲜明，高度依赖于数据分布和桶的设计

| 情况         | 时间复杂度   | 说明                                                   |
| :----------- | :----------- | :----------------------------------------------------- |
| **最优情况** | *O*(*n*)     | 数据均匀分布到各个桶，每个桶元素数量接近。             |
| **平均情况** | *O*(*n*+*k*) | *n*是元素数量，*k*是桶数量。需要遍历所有元素和所有桶。 |
| **最坏情况** | *O*(*n*^2)   | 所有数据集中到少数几个桶，退化为在桶内进行低效排序     |