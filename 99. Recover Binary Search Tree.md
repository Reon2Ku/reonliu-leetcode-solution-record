# 99. Recover Binary Search Tree

## question

You are given the `root` of a binary search tree (BST), where the values of **exactly** two nodes of the tree were swapped by mistake. *Recover the tree without changing its structure*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)

```
Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]
Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg)

```
Input: root = [3,1,4,null,null,2]
Output: [2,1,4,null,null,3]
Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[2, 1000]`.
- `-231 <= Node.val <= 231 - 1`

 

**Follow up:** A solution using `O(n)` space is pretty straight-forward. Could you devise a constant `O(1)` space solution?



## solution

首先看空间复杂度爆炸的算法：（虽然时间还蛮快的，看样子这一题的核心其实是在于对于空间复杂度的优化）

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void recoverTree(TreeNode* root) {
        int num1;
        int num2;
        stack<TreeNode*> sta;
        sta.push(root);
        vector<int> result;
        while(!sta.empty())
        {
            TreeNode* top = sta.top();
            sta.pop();
            if(top==NULL)
            {
                result.push_back(sta.top()->val);
                sta.pop();
                continue;
            }
            else if(!top->left && !top->right)
            {
                result.push_back(top->val);
                continue;
            }
            if(top->right) sta.push(top->right);
            sta.push(top);
            sta.push(NULL);
            if(top->left) sta.push(top->left); 
        }
        // for(int i=0;i<result.size();i++)
        // {
        //     cout<<result[i]<<endl;
        // }
        sort(result.begin(),result.end());
        sta.push(root);
        int count = 0;
        while(!sta.empty())
        {
            TreeNode* top = sta.top();
            sta.pop();
            if(top==NULL)
            {
                sta.top()->val = result[count];
                count++;
                sta.pop();
                continue;
            }
            else if(!top->left && !top->right)
            {
                top->val = result[count];
                count++;
                continue;
            }
            if(top->right) sta.push(top->right);
            sta.push(top);
            sta.push(NULL);
            if(top->left) sta.push(top->left); 
        }
    }
};
~~~

重新改了一下，但是好像和上面那种方法空间复杂度区别不大？我想知道问题出在哪。

时间复杂度上，确实是比第一种方法有优化，第一种方法因为有sort操作所以是NlogN，第二种方法没有sort只需要N

但是第一种方法得到的中序数组是几乎有序的，使用sort的时候，时间复杂度是趋近于N的...

AI TOOL纠正了我的观点，sort的平均和最坏时间复杂度都是NlogN

而且本体的测试用例设置并不能很好的看出两种方法的区别，反正都是0ms...

为什么空间复杂度糟糕？因为中序遍历需要的期望空间复杂度就是O(N).

本体的进阶版秒就秒在能使用O(1) 空间复杂度解决问题，名叫Morris遍历。感兴趣的话再去学吧，我反正懒得看了，看完就忘

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode* curr = new TreeNode(INT_MIN);
        TreeNode* front = curr;
        vector<TreeNode*> result(2,nullptr);
        stack<TreeNode*> sta;
        sta.push(root);
        while(!sta.empty())
        {

            TreeNode* top = sta.top();
            sta.pop();
            if(top==NULL)
            {
                front = curr;
                curr = sta.top();
                if(front->val>curr->val)
                {
                    if(result[0]==nullptr)
                    {
                        result[0] = front;
                        result[1] = curr;
                    }
                    else result[1] = curr;
                }
                sta.pop();
                continue;
            }
            else if(!top->left && !top->right)
            {
                front = curr;
                curr = top;
                if(front->val>curr->val)
                {
                    if(result[0]==nullptr)
                    {
                        result[0] = front;
                        result[1] = curr;
                    }
                    else result[1] = curr;
                }
                continue;
            }
            if(top->right) sta.push(top->right);
            sta.push(top);
            sta.push(NULL);
            if(top->left) sta.push(top->left); 
        }
        swap(result[0]->val,result[1]->val);
    }
};
~~~

