# 647.回文子串

## 题目描述

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

 

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成



## 题解

你说得对，但本题暴力解是一款时间空间均击败5%的劣质解法，你也来试试吧！

我看你是来混一题多解积分的

~~~
class Solution {
public:
    bool isPali(string s,int left, int right)
    {
        while(right>=left)
        {
            if(s[right]!=s[left])
            {
                return false;
            }
            else 
            {
                right--;
                left++;
            }
        }
        return true;
    }
    int countSubstrings(string s) {
         int result = 0;
         for(int i=0;i<s.size();i++)
         {
            for(int j=i+1;j<=s.size();j++)
            {
                if(isPali(s.substr(i,j-i),0,j-i-1)) result++;
            }
         }
         return result;
    }
};
~~~

为什么当初这题可以卡我这么久？是因为我掉入dp定式思维了吗？

（嘻嘻其实是我变牛逼了）

~~~
class Solution {
public: 
    int countSubstrings(string s) {
        vector<vector<bool>> isPali(s.size(),vector<bool>(s.size(),0));
        isPali[0][0] = 1;
        int result = s.size();
        for(int i=1;i<s.size();i++)
        {
            isPali[i][i] = 1;
            if(s[i]==s[i-1]) 
            {
                isPali[i-1][i] = 1;
                //isPali[i][i-1] = 1;
                result++;
            }
        }
        int length = 2;
        if(s.size()<3) return result;
        //cout<<result<<endl;
        for(int i=0;i<s.size()-2;i++)
        {
            for(int j=0;j<s.size()-2-i;j++)
            {
                if(s[j]==s[j+length] && isPali[j+1][j+length-1])
                {
                    isPali[j][j+length] = 1;
                    //isPali[j+length][j] = 1;
                    result++;
                }
            }
            length++;
        }
        return result;
    }
};
~~~

最后贴一个最简洁的写法，和我想的思路类似，但是人家的代码确实简洁了不少，遍历顺序，判断顺序的构建也很巧妙

~~~
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        for (int i = s.size() - 1; i >= 0; i--) {  // 注意遍历顺序
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) { // 情况一 和 情况二
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { // 情况三
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }
};
~~~

