# 617.合并二叉树

## 题目描述

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

## 题解

自己敲得，延续106的思路

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* myMerge(TreeNode* root1,TreeNode* root2)
    {
        if(root1==NULL&&root2==NULL) return NULL;
        else if(root1==NULL)
        {
            TreeNode* root = new TreeNode(root2->val);
            root->left = myMerge(NULL,root2->left);
            root->right = myMerge(NULL,root2->right);
            return root;
        } 
        else if(root2==NULL) 
        {
            TreeNode* root = new TreeNode(root1->val);
            root->left = myMerge(root1->left,NULL);
            root->right = myMerge(root1->right,NULL);
            return root;
        }
        else 
        {
            TreeNode* root = new TreeNode(root2->val+root1->val);
            root->left = myMerge(root1->left,root2->left);
            root->right = myMerge(root1->right,root2->right);
            return root;
        }
    }
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        return myMerge(root1,root2);
    }
};
~~~

标准思路好简洁。我想复杂了？

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1==NULL) return root2;
        if(root2==NULL) return root1;

        root1->val+=root2->val;

        root1->left = mergeTrees(root1->left,root2->left);
        root1->right = mergeTrees(root1->right,root2->right);

        return root1;
    }
};
~~~

标准思路中的算法思维其实是非常强的，每当我思考他为什么要这么写的时候，原因都让我非常敬佩。

迭代法：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        queue<TreeNode*> que;
        if(root1==NULL) return root2;
        if(root2==NULL) return root1;
        que.push(root1);
        que.push(root2);
        while(!que.empty())
        {
            TreeNode* node1 = que.front();que.pop();
            TreeNode* node2 = que.front();que.pop();
            
            node1->val+=node2->val;

            if(node1->left!=NULL&&node2->left!=NULL)
            {
                que.push(node1->left);
                que.push(node2->left);
            } 
            if(node1->right&&node2->right)
            {
                que.push(node1->right);
                que.push(node2->right);
            }
            //接下来两段if判断是这段代码中最巧妙的一环
            if(!node1->left&&node2->left)
            {
                node1->left = node2->left;
            }
            if(!node1->right&&node2->right)
            {
                node1->right = node2->right;
            }
        }
        
        return root1;
    }
};
~~~

