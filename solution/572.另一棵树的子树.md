# 572.另一棵树的子树

## 题目描述

给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg)

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg)

```
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
```

## 题解

101的延伸，递归法：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool compare(TreeNode* node1,TreeNode* node2)
    {
        if(node1==NULL && node2==NULL) return true;
        else if(node1==NULL) return false;
        else if(node2==NULL) return false;
        else if(node1->val!=node2->val) return false;

        bool true1 = compare(node1->left,node2->left);
        bool true2 = compare(node1->right,node2->right);
        bool isTrue = true1 && true2;
        return isTrue;
        
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        queue<TreeNode*> que;
        if(subRoot==NULL) return true;
        else if(root==NULL) return false;
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i=0;i<size;i++)
            {
                TreeNode* node = que.front();
                que.pop();
                if(compare(node,subRoot)) return true;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return false;
    }
};
~~~

迭代法：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        queue<TreeNode*> que;
        if(subRoot==NULL) return true;
        else if(root == NULL) return false;
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i=0;i<que.size();i++)
            {
                TreeNode* node = que.front();
                que.pop();
                if(node->val==subRoot->val)
                {
                    queue<TreeNode*> result;
                    result.push(node);result.push(subRoot);
                    bool flag = true;
                    while(!result.empty())
                    {
                        TreeNode* node1 = result.front(); result.pop();
                        TreeNode* node2 = result.front(); result.pop();
                        if(node1==NULL&&node2==NULL) continue;
                        else if(node1==NULL) {flag = false; break;}
                        else if(node2==NULL) {flag = false; break;}
                        else if(node1->val!=node2->val) {flag = false; break;}
                        
                        result.push(node1->left); result.push(node2->left);
                        result.push(node1->right); result.push(node2->right);
                    }
                    if(result.empty()&&flag) return true;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return false;
    }
};
~~~

