# 383.赎金信

## 题目描述

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

 

**示例 1：**

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

**示例 2：**

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
```

**示例 3：**

```
输入：ransomNote = "aa", magazine = "aab"
输出：true
```

## 题解

自己写的，这题还是简单

~~~
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char,int> result_map;
        for(int i=0;i<magazine.size();i++)
        {
            auto it = result_map.find(magazine[i]);
            if(it!=result_map.end()) it->second++;
            else result_map.insert(make_pair(magazine[i],1));
        }
        for(int i=0;i<ransomNote.size();i++)
        {
            auto it = result_map.find(ransomNote[i]);
            if(it == result_map.end()) return false;
            else 
            {
                it->second--;
                if(it->second<0) return false;
            }
        }
        return true;
    }
};
~~~

但其实有一个问题是，这道题完全是可以用数组写的，且用数组写的题解占用的空间复杂度远远小于map

再自己尝试用数组写一遍（虽然是看了标准思路的）

~~~
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int result[26] = {0};
        if(ransomNote.size()>magazine.size()) return false;
        for(int i=0;i<magazine.size();i++)
        {
            result[magazine[i]-'a']++;
        }
        for(int i=0;i<ransomNote.size();i++)
        {
            if(--result[ransomNote[i]-'a']<0) return false;
        }
        return true;
    }
};
~~~

也是通过了，然而仔细一看和上面那个方法时间空间消耗也差不多，可能是数据样本中的string不够大吧。

两个的时间复杂度都是O(n^2^)