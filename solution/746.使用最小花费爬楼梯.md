# 746.使用最小花费爬楼梯

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```





## 题解

哎哎自己想出来的最优解，我超牛的

透过这题其实可以很好的锻炼你的动态规划思维。

也就是每一个结果都可以由前几个结果推导出来

~~~
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) { 
        vector<int> result(cost.size()+1,0);
        result[0] = 0;
        result[1] = 0;
        for(int i=2;i<result.size();i++)
        {
            result[i] = min(result[i-1]+cost[i-1],result[i-2]+cost[i-2]);
            //cout<<result[i]<<endl;
        }
        return result[result.size()-1];
    }
};
~~~

