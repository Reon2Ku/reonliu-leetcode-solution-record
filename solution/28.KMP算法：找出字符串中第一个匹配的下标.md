# 28.KMP算法：找出字符串中第一个匹配的下标

## 题目描述

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

 

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```

 ## 题解

经典的情况比较难考虑齐全的题目，提交了好多次才通过，自己写的。

~~~
class Solution {
public:
    int strStr(string haystack, string needle) {
        int index = -1;
        for(int h=0,n=0;h<haystack.size();h++)
        {
            if(haystack[h]!=needle[0]) continue;
            else if(needle.size()==1)
                return h;
            else
            {
                index = h;
                while(n<needle.size()&&h<haystack.size())
                {
                    if(needle[++n]!=haystack[++h]) break;
                    if(needle[n] == haystack[h] && n!=needle.size()-1) continue;
                    if(n==needle.size()-1 && needle[n]==haystack[h]) return index;
                }
                n = 0;
                h=index;
                index = -1;
            }
        }
        return index;
    }
};
~~~

接下来是照着标准答案敲的，KMP算法，说实话能看懂个七七八八，但让我自己独立实现可能还是有困难。

KMP算法的详解见bilibili网课。看纯文字有点难理解，结合视频会更易懂一些

~~~
class Solution {
public:
    vector<int> getNext(string s)
    {
        vector<int> result = {0};
        int prefix_len = 0;
        int i = 1;
        while(i<s.size())
        {
            if(s[prefix_len]==s[i])
            {
                prefix_len++;
                result.push_back(prefix_len);
                i++;
            }
            else
            {
                if(prefix_len==0){
                    result.push_back(0);
                    i++;
                } 
                else prefix_len = result[prefix_len-1];
            }
        }
        return result;
    }

    int strStr(string haystack, string needle) {
        vector<int> next = getNext(needle);
        for(int i=0,j=0;i<haystack.size();)
        {
            if(haystack[i] == needle[j]){
                i++;j++;
            }
            else if (j>0) j = next[j-1];
            else i++;
            if(j==needle.size()) return i-j;
        }
        return -1;
    }
};
~~~

另一种写法：

~~~
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        vector<int> next(needle.size());
        getNext(&next[0], needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
~~~

哎哎彩蛋，无敌的库函数：

~~~
class Solution {
public:
    int strStr(string haystack, string needle) {
        auto index = haystack.find(needle);
        return index;
    }
};
~~~

