# 743.网络延迟时间

## 题目描述

有 `n` 个网络节点，标记为 `1` 到 `n`。

给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

```
输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
```

**示例 2：**

```
输入：times = [[1,2,1]], n = 2, k = 1
输出：1
```

**示例 3：**

```
输入：times = [[1,2,1]], n = 2, k = 2
输出：-1
```

 

**提示：**

- `1 <= k <= n <= 100`
- `1 <= times.length <= 6000`
- `times[i].length == 3`
- `1 <= ui, vi <= n`
- `ui != vi`
- `0 <= wi <= 100`
- 所有 `(ui, vi)` 对都 **互不相同**（即，不含重复边）



## 题解

复杂度为n^2的朴素dijkstra

~~~
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<bool> visited(n+1,0);
        visited[k] = 1;
        vector<vector<int>> edge(n+1,vector<int>(n+1,INT_MAX));
        vector<int> dijkstra(n+1,INT_MAX);
        dijkstra[k] = 0;
        for(int i=0;i<times.size();i++)
        {
            edge[times[i][0]][times[i][1]] = times[i][2];
        }
        //cout<<edge.size()<<" "<<edge[0].size()<<endl;
        // for(int i=0;i<n+1;i++)
        // {
        //     for(int j=0;j<n+1;j++)
        //     {
        //         cout<<edge[i][j]<<" ";
        //     }
        //     cout<<endl;
        // }
        int currIndex = k;
        for(int i=1;i<n;i++)
        {
            //cout<<"curr:"<<currIndex<<endl;
            int minDis = INT_MAX;
            int minIndex = -1;
            for(int j=1;j<n+1;j++)
            {
                if(visited[j] || edge[currIndex][j]==INT_MAX) continue;
                int sum = edge[currIndex][j]+dijkstra[currIndex];
                if(sum<dijkstra[j]) 
                {
                    //cout<<"test"<<endl;
                    dijkstra[j] = sum;
                }
            }
            for(int j=1;j<n+1;j++)
            {
                if(visited[j]) continue;
                if(dijkstra[j]<minDis)
                {
                    //cout<<"test"<<endl;
                    minIndex = j;
                    minDis = dijkstra[j];
                }
            }
            if(minIndex==-1) return -1;
            currIndex = minIndex;
            //cout<<"currafter:"<<currIndex<<endl;
            visited[currIndex] = 1;
        }
        return dijkstra[currIndex];
    }
};
~~~

我们再来看一种堆优化法。这种方法比较抽象，理解起来很困难，花了我很多时间。

但是这种方法最核心的收获其实是让我深刻的理解了priority_queue这种堆结构的使用。

估计我过段时间就会忘，但学一下这种东西并没有坏处。

~~~
class Solution {
public:
    //定义一个结构体来表示带权重的边
    struct Edge
    {
        int vertex;
        int value;
        Edge(int v, int a):vertex(v),value(a) {}
    };
    //小顶堆
    class mycomparision
    {
        public:
        bool operator()(const pair<int,int>& lhs,const pair<int,int>& rhs)
        {
            return lhs.second>rhs.second;
            //小顶堆
        }
    };
    
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<list<Edge>> grid(n+1);
        for(int i=0;i<times.size();i++)
        {
            grid[times[i][0]].push_back(Edge(times[i][1],times[i][2]));
        }
        //int start = k;
        vector<int> minDist(n+1,INT_MAX);
        vector<bool> visited(n+1,0);
        //优先队列中存放pair<节点编号，原点到该节点的权值>
        priority_queue<pair<int,int>,vector<pair<int,int>>,mycomparision> pq;
        pq.push(pair<int,int>(k,0));
        //初始化队列，原点到原点的距离为0，所以初始化为0
        minDist[k] = 0;
        //起点到起点的最小距离为0
        while(!pq.empty())
        {
            pair<int,int> curr = pq.top(); pq.pop();
            if(visited[curr.first]) continue;
            //找到优先队列中未被访问的节点
            visited[curr.first] = true;
            //标记未访问的节点为true，表示现在开始访问

            //更新minDist数组
            for(Edge edge:grid[curr.first])
            //对于grid[curr.first]当前访问节点，遍历其所有可达节点
            //其中edge用于存储访问到的单个节点
            {
                if(!visited[edge.vertex] && minDist[curr.first]+edge.value<minDist[edge.vertex])
                {
                    //更新minDist
                    minDist[edge.vertex] = minDist[curr.first]+edge.value;
                    pq.push(pair<int,int>(edge.vertex,minDist[edge.vertex]));
                }
            }
        }
        int maxvalue = INT_MIN;
        for(int i=1;i<n+1;i++)
        {
            if(minDist[i]>maxvalue) maxvalue = minDist[i];
        }
        if(maxvalue==INT_MAX) return -1;
        else return maxvalue;
        
    }
};
~~~

