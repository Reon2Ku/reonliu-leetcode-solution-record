# 150.逆波兰表达式求值

## 题目描述

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。



## 题解

比想象中的简单，性能也没有特别差就是普通的O(n)

~~~
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<string> myStack;
        int operand1,operand2;
        for(int i=0;i<tokens.size();i++)
        {
            if(myStack.empty()) myStack.push(tokens[i]);
            
            else if(tokens[i]=="+")
            {
                operand1 = stoi(myStack.top());
                myStack.pop();
                operand2 = stoi(myStack.top());
                myStack.pop();
                myStack.push(to_string(operand2+operand1));
            }
            else if(tokens[i]=="-")
            {
                operand1 = stoi(myStack.top());
                myStack.pop();
                operand2 = stoi(myStack.top());
                myStack.pop();
                myStack.push(to_string(operand2-operand1));
            }
            else if(tokens[i]=="*")
            {
                operand1 = stoi(myStack.top());
                myStack.pop();
                operand2 = stoi(myStack.top());
                myStack.pop();
                myStack.push(to_string(operand2*operand1));
            }
            else if(tokens[i]=="/")
            {
                operand1 = stoi(myStack.top());
                myStack.pop();
                operand2 = stoi(myStack.top());
                myStack.pop();
                myStack.push(to_string(operand2/operand1));
            }
            else myStack.push(tokens[i]);
        }
        return stoi(myStack.top());
    }
};
~~~

看看标准解吧，思路差不多，人家明显更加简洁一点。我自己写的重复代码比较多。

~~~
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 力扣修改了后台测试数据，需要用longlong
        stack<long long> st; 
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                long long num1 = st.top();
                st.pop();
                long long num2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            } else {
                st.push(stoll(tokens[i]));
            }
        }

        int result = st.top();
        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）
        return result;
    }
};
~~~

### 题外话

我们习惯看到的表达式都是中缀表达式，因为符合我们的习惯，但是中缀表达式对于计算机来说就不是很友好了。

例如：4 + 13 / 5，这就是中缀表达式，计算机从左到右去扫描的话，扫到13，还要判断13后面是什么运算符，还要比较一下优先级，然后13还和后面的5做运算，做完运算之后，还要向前回退到 4 的位置，继续做加法，你说麻不麻烦！

那么将中缀表达式，转化为后缀表达式之后：["4", "13", "5", "/", "+"] ，就不一样了，计算机可以利用栈来顺序处理，不需要考虑优先级了。也不用回退了， **所以后缀表达式对计算机来说是非常友好的。**

可以说本题不仅仅是一道好题，也展现出计算机的思考方式。

在1970年代和1980年代，惠普在其所有台式和手持式计算器中都使用了RPN（后缀表达式），直到2020年代仍在某些模型中使用了RPN。