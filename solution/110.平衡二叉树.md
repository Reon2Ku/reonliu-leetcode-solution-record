# 110.平衡二叉树

## 题目描述

给定一个二叉树，判断它是否是 

平衡二叉树

 



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```

## 题解

我嘞个自己写的O(n^2^)呐。我自己都看不太明白，这代码突然就能自己跑起来了。喜欢我119ms打败5%用户吗

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getmaxDepth(TreeNode* node)
    {
        if(node==NULL) return 0;
        return 1+max(getmaxDepth(node->left),getmaxDepth(node->right));
    }
    bool isBalanced(TreeNode* root) {
        if(root==NULL) return true;
        int leftDepth=getmaxDepth(root->left);
        int rightDepth=getmaxDepth(root->right);
        bool flag1 = abs(leftDepth-rightDepth)<=1;
        bool flag2 = isBalanced(root->left);
        bool flag3 = isBalanced(root->right);
        return flag1&&flag2&&flag3;        
    }
};
~~~

转换一下思路。

其实这题没有你想象的那么复杂，正常写一个迭代就可以实现非常高效的时间复杂度。

注意：求深度要用广度优先遍历，而求高度应当用深度优先遍历。

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getDepth(TreeNode* root)
    {
        if(root==NULL) return 0;
        return 1+max(getDepth(root->left),getDepth(root->right));
    }
    bool isBalanced(TreeNode* root) {
        stack<TreeNode*> sta;
        if(root==NULL) return true;
        sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            if(abs(getDepth(node->left)-getDepth(node->right))>1) return false;
            if(node->left) sta.push(node->left);
            if(node->right) sta.push(node->right);
        }
        return true;
    }
};
~~~

自己写的递归，越来越感觉递归法总是莫名其妙就通过了。我最开始到底是怎么写出那么麻烦那么耗时的递归的。难道是因为采用的是广度优先遍历吗？

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getDepth(TreeNode* root)
    {
        if(root==NULL) return 0;
        return 1+max(getDepth(root->left),getDepth(root->right));
    }
    bool isBalanced(TreeNode* root) {
        if(root==NULL) return true;
        if(abs(getDepth(root->left)-getDepth(root->right))>1) return false;
        return isBalanced(root->left)&&isBalanced(root->right);
    }
};
~~~

