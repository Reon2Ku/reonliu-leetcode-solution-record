# 827.最大人工岛

## 题目描述

给你一个大小为 `n x n` 二进制矩阵 `grid` 。**最多** 只能将一格 `0` 变成 `1` 。

返回执行此操作后，`grid` 中最大的岛屿面积是多少？

**岛屿** 由一组上、下、左、右四个方向相连的 `1` 形成。

 

**示例 1:**

```
输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
```

**示例 2:**

```
输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
```

**示例 3:**

```
输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。
```

 

**提示：**

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 500`
- `grid[i][j]` 为 `0` 或 `1`



## 题解

使用牺牲内存的宝丽洁，胜利是必然的，单杀hard战绩可查

~~~
class Solution {
public:
    //int count = 0;
    void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j, int& area, int index, vector<vector<int>>& islandIndex)
    {
        //count++;
        if(grid[i][j]==0) 
        {
            visited[i][j] = 1;
            return;
        }
        else  
        {
            islandIndex[i][j] = index;
            visited[i][j] = 1;
            area++;
        }
        if(i+1<grid.size() && !visited[i+1][j]) dfs(grid,visited,i+1,j,area,index,islandIndex);
        if(j+1<grid.size() && !visited[i][j+1]) dfs(grid,visited,i,j+1,area,index,islandIndex);
        if(i-1>=0 && !visited[i-1][j]) dfs(grid,visited,i-1,j,area,index,islandIndex);
        if(j-1>=0 && !visited[i][j-1]) dfs(grid,visited,i,j-1,area,index,islandIndex);
    }

    int largestIsland(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<bool>> visited(n,vector<bool>(n,0));//用于区分孤岛
        vector<int> islandArea(1,0);//用来记录每个孤岛的面积，index0记录0，从1开始记录孤岛
        vector<vector<int>> islandIndex(n,vector<int>(n,0));//用来记录每个节点属于几号岛
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==1&&!visited[i][j])
                {
                    int area = 0;
                    dfs(grid,visited,i,j,area,islandArea.size(),islandIndex);
                    islandArea.push_back(area);
                }
            }
        }

        // for(int i=0;i<islandArea.size();i++)
        // {
        //     cout<<islandArea[i]<<endl;
        // }

        if(islandArea.size()==1) return 1;
        int result = islandArea[1];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                //cout<<islandIndex[i][j]<<" ";
                if(grid[i][j]==0)
                {
                    vector<bool> surrondings(islandArea.size(),true);
                    int sumArea = 1;
                    if(i+1<n&&surrondings[islandIndex[i+1][j]])
                    {
                        sumArea+=islandArea[islandIndex[i+1][j]];
                        surrondings[islandIndex[i+1][j]] = false;
                    } 
                    if(j+1<n&&surrondings[islandIndex[i][j+1]])
                    {
                        sumArea+=islandArea[islandIndex[i][j+1]];
                        surrondings[islandIndex[i][j+1]] = false;
                    } 
                    if(i-1>=0&&surrondings[islandIndex[i-1][j]]) 
                    {
                        sumArea+=islandArea[islandIndex[i-1][j]];
                        surrondings[islandIndex[i-1][j]] = false;
                    }
                    if(j-1>=0&&surrondings[islandIndex[i][j-1]])
                    {
                        sumArea+=islandArea[islandIndex[i][j-1]];
                        surrondings[islandIndex[i][j-1]] = false;
                    } 
                    // for(int k=0;k<surrondings.size();k++)
                    // {
                    //     if(surrondings[k]) sumArea+=islandArea[k];
                    // }
                    result = max(result,sumArea);
                }
            }
            //cout<<endl;
        }
        //cout<<result<<endl;
        //cout<<count<<endl;

        return result;
    }
};
~~~

