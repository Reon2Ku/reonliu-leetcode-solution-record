# 86. Partition List

## question

Given the `head` of a linked list and a value `x`, partition it such that all nodes **less than** `x` come before nodes **greater than or equal** to `x`.

You should **preserve** the original relative order of the nodes in each of the two partitions.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```
Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]
```

**Example 2:**

```
Input: head = [2,1], x = 2
Output: [1,2]
```

 

**Constraints:**

- The number of nodes in the list is in the range `[0, 200]`.
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`



## solution

沙比天天写暴力解是吧

好吧只是空间上的暴力解，时间复杂度还是很美丽的。

也不见得，你这种方法需要遍历两次链表。但是更好的解法是只需要遍历一次链表的。

~~~
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        vector<int> before;
        vector<int> after;
        ListNode* curr = head;
        while(curr)
        {
            if(curr->val<x) before.push_back(curr->val);
            else after.push_back(curr->val);
            curr = curr->next;
        }
        curr = head;
        int count1 = 0;
        int count2 = 0;
        while(curr)
        {
            if(count1<before.size())
            {
                curr->val = before[count1];
                count1++;
            }
            else
            {
                curr->val = after[count2];
                count2++;
            }
            curr = curr->next;
        }
        return head;
    }
};
~~~

你的方法整体思路是对的，但是空间复杂度非常差。经过官方题解提醒，我发现问题的根源在于：你如果采用如上分割方式，会导致必须要申请额外的vector数组空间。而如果直接使用链表操作，分成一个before链表和一个after链表，那就几乎不怎么需要额外的空间开销。如下是自己写的解：

~~~
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* curr = head;
        ListNode* leftListHead = new ListNode(0);
        ListNode* rightListHead = new ListNode(0);
        ListNode* left = leftListHead;
        ListNode* right = rightListHead;
        while(curr)
        {
            //cout<<curr->val<<endl;
            if(curr->val<x)
            {
                left->next = curr;
                left = left->next;
            }
            else if(curr->val>=x)
            {
                right->next = curr;
                right = right->next;
            }
            curr = curr->next;
        }
        right->next = nullptr;//因为你忘记将right后面的节点设置为null指针，导致了环的出现，同时你设置断点了也不能很好地定位到问题在哪一行。下辈子注意点。这样的bug我还是第一次见
        left->next = rightListHead->next;
        return leftListHead->next;
    }
};
~~~

