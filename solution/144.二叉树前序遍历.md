# 144.二叉树前序遍历

## 题目描述

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
输入：root = [1,2]
输出：[1,2]
```

**示例 5：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
输入：root = [1,null,2]
输出：[1,2]
```

## 题解

刚入门可以说是一窍不通了，先来看简单的递归法。（虽然说我自己也想不出来就是了）

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void preTraversal(TreeNode* curr, vector<int>& vec)
    {
        if(curr==nullptr) return;
        vec.push_back(curr->val);
        preTraversal(curr->left,vec);
        preTraversal(curr->right,vec);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        preTraversal(root,result);
        return result;
    }
};
~~~

接下来我们尝试写迭代算法前序遍历二叉树。有下面那张动态示意图加上代码其实不难理解这段前序遍历的逻辑

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> myStack;
        vector<int> result;
        if(root == NULL) return result;
        myStack.push(root);
        while(!myStack.empty())
        {
            TreeNode* node = myStack.top();
            myStack.pop();
            result.push_back(node->val);
            if(node->right) myStack.push(node->right);
            if(node->left) myStack.push(node->left); 
        }
        return result;
    }
};
~~~

### 前序遍历（迭代法）

我们先看一下前序遍历。

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

动画如下：

![二叉树前序遍历（迭代法）](https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

然而这种迭代法技巧性太强了，有没有什么逻辑性又强又不需要很强技巧性的迭代法呢？

来看统一风格迭代法

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> sta;
        if(root==NULL) return result;
        sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            if(node!=NULL)
            {
                sta.pop();
                if(node->right) sta.push(node->right);

                if(node->left) sta.push(node->left);

                sta.push(node);
                sta.push(NULL);//标记node节点，表示已访问但未添加到result数组
            }
            else
            {
                sta.pop();
                node = sta.top();
                result.push_back(node->val);
                sta.pop();
            }
        }
        return result;
    }
};
~~~

从根节点开始，我们既希望利用这个根节点访问到他的左右子节点（如果有的话），有希望最后能够将其放入result集中正确的位置。所以我们一开始将根节点放入栈中之后要做几件事：①把他取出来②把他的右孩子放进栈③把他自己放进栈④加入一个null节点表示我们已经使用这个root访问过了左右子节点⑤把他的左孩子放入栈。

如此一来我们就形成了一个右中左的栈，先进后出的原则会将输出结果顺序颠倒变为左中右实现中序遍历

以中序遍历为例，我们需要在前序遍历中做的事（构建右左中，颠倒后变为中左右）以及后序遍历中做的事（构建中右左，颠倒后变为左右中）其实是类似的，可以像递归法中仅更改代码中少量代码的顺序即可实现。