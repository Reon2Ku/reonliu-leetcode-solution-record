# 257.二叉树的所有路径

## 题目描述

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

## 题解

汗流浃背了，自己想了老久之后用丑陋的方法解决了

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        if(root==NULL) return result;
        stack<TreeNode*> sta;
        string temp="";
        sta.push(root);
        int depth=0;
        vector<string> back;
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();

            if(node!=NULL)
            {
                depth++;
                if(node!=root)
                {
                    temp+="->";
                    sta.push(NULL);
                } 
                temp+=to_string(node->val);
                back.push_back("");
                back[depth-1]+=to_string(node->val);
                if(!node->left&&!node->right)
                {
                    result.push_back(temp);
                }
                
                if(node->right) sta.push(node->right);
                if(node->left) sta.push(node->left);
            }
            else
            {
                depth--;
                for(int i=0;i<back[depth].size()+2;i++)
                {
                    temp.pop_back();
                }
                back.pop_back();
            }
        }
        return result;
    }
};
~~~

我自己的代码是使用了depth和vector<string>共同实现字符串的回退。但是很显然，在这项工作中stack更能胜任。优化后，时耗从11ms优化到了3ms

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        if(root==NULL) return result;
        stack<TreeNode*> sta;
        string temp="";
        sta.push(root);
        stack<string> back;
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();

            if(node!=NULL)
            {
                if(node!=root)
                {
                    temp+="->";
                    sta.push(NULL);
                } 
                temp+=to_string(node->val);
                back.push(to_string(node->val));

                if(!node->left&&!node->right)
                {
                    result.push_back(temp);
                }
                
                if(node->right) sta.push(node->right);
                if(node->left) sta.push(node->left);
            }
            else
            {
                temp.resize(temp.size()-(back.top().size()+2));
                back.pop();
            }
        }
        return result;
    }
};
~~~

接下来是代码随想录的迭代法：11ms，感觉不如我

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        if(root==NULL) return result;
        stack<TreeNode*> sta;
        sta.push(root);
        stack<string> back;
        back.push(to_string(root->val));
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            sta.pop();
            string path = back.top();back.pop();
            if(!node->left&&!node->right)
            {
                result.push_back(path);
            }
            
            if(node->right) 
            {
                sta.push(node->right);
                back.push(path+"->"+to_string(node->right->val));//个人感觉最精髓的地方
            }
            if(node->left)
            {
                sta.push(node->left);
                back.push(path+"->"+to_string(node->left->val));//同
            }
        }
        return result;
    }
};
~~~

最后是代码随想录的递归法，据说会用到回溯算法的思维，这也是这道题的核心目的之一：为之后的回溯算法学习打好基础。

尽管整体的逻辑和迭代思路差不多，但是递归更加简洁直观，便于理解。7ms

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void travese(TreeNode* node,vector<int>& path,vector<string>& result)
    {
        path.push_back(node->val);

        if(!node->left&&!node->right)
        {
            string mPath;
            for(int i=0;i<path.size()-1;i++)
            {
                mPath += to_string(path[i]);
                mPath += "->";
            }
            mPath+=to_string(path[path.size()-1]);
            result.push_back(mPath);
            return;
        }
        if(node->left)
        {
            travese(node->left,path,result);
            path.pop_back();//pop_back写在这里实现反复的回溯直到最上面那个节点位置
            //要是pop_back写在上面那个if中的话就只能回溯一层，不符合要求。
        }
        if(node->right)
        {
            travese(node->right,path,result);
            path.pop_back();
        }

    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<int> path;
        vector<string> result;
        if(root==NULL) return result;
        travese(root,path,result);
        return result;
    }
};
~~~

回溯递归：这一段看着很简洁很抽象，实际上在草稿纸上模拟一下程序运行过程就能发现其中的奥妙之处。

体会一下回溯思维吧，目前让我写我还写不出这样的。写出迭代已经是我的极限了

~~~
class Solution {
private:

    void traversal(TreeNode* cur, string path, vector<string>& result) {
        path += to_string(cur->val); // 中
        if (cur->left == NULL && cur->right == NULL) {
            result.push_back(path);
            return;
        }
        if (cur->left) traversal(cur->left, path + "->", result); // 左
        if (cur->right) traversal(cur->right, path + "->", result); // 右
    }

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        string path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;
    }
};
~~~



