# 卡码网101.孤岛总面积

## 题目描述

###### 题目描述

给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。



现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。

###### 输入描述

第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。

###### 输出描述

输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。

###### 输入示例

```
4 5
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
```

###### 输出示例

```
1
```

###### 提示信息

![img](https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412113711_58587.png)



在矩阵中心部分的岛屿，因为没有任何一个单元格接触到矩阵边缘，所以该岛屿属于孤岛，总面积为 1。



数据范围：

1 <= M, N <= 50。



## 题解

~~~
#include<iostream>
#include<vector>
using namespace std;

void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j, int& Area, bool& flag)
{
    if(grid[i][j]==0) return;
    else 
    {
        visited[i][j]=1;
        Area++;
    }
    if(flag)
    {
        if(i==0||j==0||i==grid.size()-1||j==grid[0].size()-1) flag = false;
    }
    if(i+1<grid.size()&&!visited[i+1][j]) dfs(grid,visited,i+1,j,Area,flag);
    if(j+1<grid[0].size()&&!visited[i][j+1]) dfs(grid,visited,i,j+1,Area,flag);
    if(i-1>=0&&!visited[i-1][j]) dfs(grid,visited,i-1,j,Area,flag);
    if(j-1>=0&&!visited[i][j-1]) dfs(grid,visited,i,j-1,Area,flag);
}

int main()
{
    int n,m;
    cin>>n>>m;
    vector<vector<int>> grid(n,vector<int>(m,0));
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            cin>>grid[i][j];
        }
    }
    //cout<<"test"<<endl;
    if(grid.size()==0) return 0;
    //cout<<"test"<<endl;
    int totalArea = 0;
    //cout<<"test"<<endl;
    vector<vector<bool>> visited(n,vector<bool>(m,0));
    //cout<<"test"<<endl;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(!visited[i][j]&&grid[i][j]==1)
            {
                bool flag = true;//表示是孤岛
                int Area = 0;
                dfs(grid,visited,i,j,Area,flag);
                if(flag)
                {
                    totalArea+=Area;
                    //cout<<"area plus at"<<i<<" "<<j<<endl;
                }
            }
        }
    }
    // for(int i=0;i<n;i++)
    // {
    //     for(int j=0;j<m;j++)
    //     {
    //         cout<<grid[i][j];
    //     }
    //     cout<<endl;
    // }
    cout<<totalArea;
}
~~~

