# 559.N叉树的最大深度

## 题目描述

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：3
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

```
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5
```

## 题解

广度优先遍历，迭代法

~~~
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) {
        queue<Node*> que;
        if(root==NULL) return 0;
        que.push(root);
        int result = 0;
        while(!que.empty())
        {
            int size = que.size();
            for(int i=0;i<size;i++)
            {
                Node* node = que.front();
                que.pop();
                for(int j=0;j<node->children.size();j++)
                {
                    que.push(node->children[j]);
                }
            }
            result++;
        }
        return result;
    }
};
~~~

自己写的递归：

~~~
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int getMax(Node* node)
    {
        if(node==NULL) return 0;
        int maxNum = 1;
        for(int i=0;i<node->children.size();i++)
        {
            int childrenDepth = 1+getMax(node->children[i]);
            if(maxNum>childrenDepth) continue;
            else maxNum=childrenDepth;
        }
        return maxNum;
    }
    int maxDepth(Node* root) {
        return getMax(root);
    }
};
~~~

