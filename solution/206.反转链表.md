# 206.反转链表

## 题目描述

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```



## 题解

我自己的解法：水波暴力解法，用数组存储老的链表，再倒过来一个个赋值给新链表。

说实话有点过于弱智了不过解出来了就可以

`````
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *curr = head;
        vector<int> ListNodeArr;
        while(curr!=nullptr)
        {
            ListNodeArr.push_back(curr->val);
            curr = curr->next;
        }
        int size = ListNodeArr.size();
        ListNode *newHead = new ListNode(0);
        curr = newHead;
        while(size--)
        {
            curr->next = new ListNode(ListNodeArr[size]);//由于在while括号中已经自减过了，所以此处直接用size即可
            curr = curr->next;
        }
        return newHead->next;
    }
};
`````

接下来我们顺着标准答案的思路自己写一遍：双指针法，声明一个curr和一个temp指针存储指针并且给每个节点的next重新赋值

![img](https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)

`````
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *curr = head;
        ListNode *prev = nullptr;//唯一bug,我一开始声明了一个新的节点，但似乎直接把prev声明称nullptr即可
        //只要你引入了新的节点，那就一定会有一个默认值0，最终导致输出错误。
        while(curr!=nullptr)
        {
            ListNode *temp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = temp;            
        }
        return prev;
    }
};//时间复杂度: O(n)
//空间复杂度: O(1)
`````



递归法：好抽象,但在自己理解了双指针法的前提下，配合注释还是比较好理解的

从前往后翻转

`````
class Solution {
public:
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(cur == NULL) return pre;
        ListNode* temp = cur->next;
        cur->next = pre;
        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
        return reverse(cur,temp);
    }
    ListNode* reverseList(ListNode* head) {
        // 和双指针法初始化是一样的逻辑
        // ListNode* cur = head;
        // ListNode* pre = NULL;
        return reverse(NULL, head);
    }

};//时间复杂度: O(n), 要递归处理链表的每个节点
//空间复杂度: O(n), 递归调用了 n 层栈空间
`````



`````
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 边缘条件判断，当仅有一个节点，返回头。没有节点，返回NULL
        if(head == NULL) return NULL;
        if (head->next == NULL) return head;
        
        //用last指向最后一个节点（由于head->next == NULL时会返回head，因此以下语句可以用last获取到最后一个节点
        ListNode *last = reverseList(head->next);
        //在获取到last的同时，也调用了多次reverseList，并且是以逆序的形式从后往前翻转（递归）
        
        // 翻转头节点与第二个节点的指向
        //下列语句会从导数第二个节点开始执行起
        head->next->next = head;
        
        // 此时的 head 节点为尾节点，next 需要指向 NULL
        head->next = NULL;
        
        return last;
        //last值在获取到尾节点后就不会在变化，但需要return一级级往上传递
    }
};
//可以发现这种逆序翻转的方法巧妙的避免使用了temp指针，但我自己确实想不到。
//时间复杂度: O(n)
//空间复杂度: O(n)
`````

