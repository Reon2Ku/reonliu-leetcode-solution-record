# 1135.最低成本连通所有城市

## 题目描述

想象一下你是个城市基建规划者，地图上有 `n` 座城市，它们按以 `1` 到 `n` 的次序编号。

给你整数 `n` 和一个数组 `conections`，其中 `connections[i] = [xi, yi, costi]` 表示将城市 `xi` 和城市 `yi` 连接所要的`costi`（**连接是双向的**）。

返回连接所有城市的**最低成本**，每对城市之间**至少**有一条路径。如果无法连接所有 `n` 个城市，返回 `-1`

该 **最小成本** 应该是所用全部连接成本的总和。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/27/1314_ex2.png)

```
输入：n = 3, conections = [[1,2,5],[1,3,6],[2,3,1]]
输出：6
解释：选出任意 2 条边都可以连接所有城市，我们从中选取成本最小的 2 条。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/27/1314_ex1.png)

```
输入：n = 4, conections = [[1,2,3],[3,4,4]]
输出：-1
解释：即使连通所有的边，也无法连接所有城市。
```

 

**提示：**

- `1 <= n <= 104`
- `1 <= connections.length <= 104`
- `connections[i].length == 3`
- `1 <= xi, yi <= n`
- `xi != yi`
- `0 <= costi <= 105`



## 题解

看了随想录的kruscal算法加上并查集之后，轻松解决。

prim算法似乎是针对：知道两点，可以轻松求出边的情况。

kruscal算法则是主要用于：知道边可以轻松找到边的两点的情况。

~~~
class Solution {
public:
    vector<int> father = vector<int>(10001,0);
    int findRoot(int u)
    {
        if(father[u]==u) return u;
        else return father[u] = findRoot(father[u]);
    }

    bool sameRoot(int u,int v)
    {
        if(findRoot(u)==findRoot(v)) return true;
        else return false;
    }

    void join(int u,int v)
    {
        int ur = findRoot(u);
        int vr = findRoot(v);
        if(ur==vr) return;
        else father[vr] = father[ur];
    }

    int minimumCost(int n, vector<vector<int>>& connections) {
        sort(connections.begin(),connections.end(),[](const vector<int>& a,const vector<int>& b){
            return a[2]<b[2];
        });
        int result = 0;
        for(int i=0;i<n+1;i++)
        {
            father[i] = i;
        }
        // for(int i=0;i<connections.size();i++)
        // {
        //     for(int j=0;j<3;j++)
        //     {
        //         cout<<connections[i][j]<<" ";
        //     }
        //     cout<<endl;
        // }
        for(int i=0;i<connections.size();i++)
        {
            if(!sameRoot(connections[i][0],connections[i][1]))
            {
                join(connections[i][0],connections[i][1]);
                result += connections[i][2];
            }
        }
        for(int i=2;i<n+1;i++)
        {
            if(!sameRoot(1,i)) return -1;
        }
        return result;
    }
};
~~~

