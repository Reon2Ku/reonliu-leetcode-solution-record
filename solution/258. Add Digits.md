# 258. Add Digits

Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.

 

**Example 1:**

```
Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.
```

**Example 2:**

```
Input: num = 0
Output: 0
```

 

**Constraints:**

- `0 <= num <= 231 - 1`

 

**Follow up:** Could you do it without any loop/recursion in `O(1)` runtime?



## solution

~~~
class Solution {
public:
    int addDigits(int num) {
        while(num>9)
        {
            int sum = 0;
            while(num>0)
            {
                sum+=num%10;
                num/=10;
            }
            num = sum;
        }
        return num;
    }
};
~~~

谁能想到第二种简便方法反而速度慢性能差？

差的原因在于，其实这是递归思路

~~~
class Solution {
public:
    int addDigits(int num) {
        while(num>9)
        {
            num = num/10 + num%10;
        }
        return num;
    }
};
~~~

最强的办法：

除了传统的单纯循环，还可以找规律。假如一个三位数'abc'，其值大小为s1 = 100 * a + 10 * b + 1 * c，经过一次各位相加后，变为s2 = a + b + c，减小的差值为(s1 -s2) = 99 * a + 9 * b，差值可以被9整除，每一个循环都这样，缩小了9的倍数。当num小于9，即只有一位时，直接返回num，大于9时，如果能被9整除，则返回9（因为不可能返回0也不可能返回两位数及以上的值），如果不能被整除，就返回被9除的余数。

~~~
class Solution {
public:
    int addDigits(int num) {
        if(num>9)
        {
            num = num%9;
            if(num==0) return 9;
        } 
        return num;
        
    }
};
~~~

