# 684.冗余链接

## 题目描述

树可以看成是一个连通且 **无环** 的 **无向** 图。

给定一个图，该图从一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后获得。添加的边的两个不同顶点编号在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。

 

**示例 1：**

![img](https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png)

```
输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]
```

**示例 2：**

![img](https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png)

```
输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
```

 

**提示:**

- `n == edges.length`
- `3 <= n <= 1000`
- `edges[i].length == 2`
- `1 <= ai < bi <= edges.length`
- `ai != bi`
- `edges` 中无重复元素
- 给定的图是连通的 



## 题解

并查集公式模板题

~~~
class Solution {
public:
    vector<int> father = vector<int>(1001,0);
    int findRoot(int u)
    {
        if(u == father[u]) return u;
        else return father[u] = findRoot(father[u]);
    }
    bool sameRoot(int u, int v)
    {
        if(findRoot(u)==findRoot(v)) return true;
        else return false;
    }
    void join(int u,int v)
    {
        int uf = findRoot(u);
        int vf = findRoot(v);
        if(uf == vf) return;
        else father[uf] = vf;
    }
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        vector<int> result;
        for(int i=0;i<edges.size();i++) father[i] = i;
        for(int i=0;i<edges.size();i++)
        {
            int u = edges[i][0];
            int v = edges[i][1];
            if(sameRoot(u,v)) return edges[i];
            join(u,v);
        }
        return result;
    }
};
~~~

