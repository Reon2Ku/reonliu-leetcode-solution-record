# 101.对称二叉树

## 题目描述

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`



## 题解

reverse函数太伟大啦。疑似是已经建立起一点reverse文字游戏的算法思维了，自己写的

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> que;
        if(root == NULL) return true;
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
            vector<int> rev;
            for(int i=0;i<size;i++)
            {
                TreeNode* node = que.front();
                que.pop();
                if(node!=NULL)
                {
                    vec.push_back(node->val);
                    if(node->left) que.push(node->left);
                    else que.push(NULL);
                    if(node->right) que.push(node->right);
                    else que.push(NULL);
                }
                else vec.push_back(101);
            }
            rev = vec;
            reverse(vec.begin(),vec.end());
            if(vec!=rev) return false;
        }
        return true;
    }
};
~~~

四不像递归法：我请问了你真的是递归吗？不过是利用递归访问到每个元素而已。

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void symmetric(vector<vector<int>>& vec,TreeNode* root,int depth)
    {
        if(root==NULL) 
        {
            if(vec.size()==depth) vec.push_back(vector<int>());
            vec[depth].push_back(101);
            return;
        }
        if(vec.size()==depth) vec.push_back(vector<int>());
        vec[depth].push_back(root->val);
        symmetric(vec,root->left,depth+1);
        symmetric(vec,root->right,depth+1);
    }
    bool isSymmetric(TreeNode* root) {
        int depth = 0;
        vector<vector<int>> vec;
        symmetric(vec,root,depth);
        for(int i=0;i<vec.size();i++)
        {
            vector<int> result = vec[i];
            reverse(vec[i].begin(),vec[i].end());
            if(result == vec[i]) continue;
            else return false;
        }
        return true;
    }
};
~~~

接下来看看代码随想录的思路写写：递归法

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool symmetric(TreeNode* left, TreeNode* right)
    {
        if(left==NULL&&right==NULL) return true;
        else if(left!=NULL&&right==NULL) return false;
        else if(left==NULL&&right!=NULL) return false;
        else if(left->val!=right->val) return false;

        bool true1 = symmetric(left->left,right->right);
        bool true2 = symmetric(left->right,right->left);
        bool isTrue = true1&&true2;
        return isTrue;
    }
    bool isSymmetric(TreeNode* root) {
        if(root==NULL) return true;
        return symmetric(root->left,root->right);
    }
};
~~~

迭代法。这个迭代的思路还是非常巧妙的，值得一敲

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> que;
        if(root==NULL) return true;
        que.push(root->left);
        que.push(root->right);
        while(!que.empty())
        {
            TreeNode* node1 = que.front(); que.pop();
            TreeNode* node2 = que.front(); que.pop();
            if(!node1 && !node2) continue;
            if(!node1 ||!node2 || node1->val!=node2->val) return false;
            que.push(node1->left); que.push(node2->right);
            que.push(node1->right); que.push(node2->left);
        }
        return true;
    }
};
~~~

同迭代，因为是成对取出存放的，所以用queue或者stack都没有区别

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        stack<TreeNode*> sta;
        if(root==NULL) return true;
        sta.push(root->left);
        sta.push(root->right);
        while(!sta.empty())
        {
            TreeNode* node1 = sta.top(); sta.pop();
            TreeNode* node2 = sta.top(); sta.pop();
            if(!node1 && !node2) continue;
            if(!node1 ||!node2 || node1->val!=node2->val) return false;
            sta.push(node1->left); sta.push(node2->right);
            sta.push(node1->right); sta.push(node2->left);
        }
        return true;
    }
};
~~~

