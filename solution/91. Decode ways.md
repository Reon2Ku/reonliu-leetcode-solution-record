# 91. Decode ways

## description

You have intercepted a secret message encoded as a string of numbers. The message is **decoded** via the following mapping:

```
"1" -> 'A' "2" -> 'B' ... "25" -> 'Y' "26" -> 'Z'
```

However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (`"2"` and `"5"` vs `"25"`).

For example, `"11106"` can be decoded into:

- `"AAJF"` with the grouping `(1, 1, 10, 6)`
- `"KJF"` with the grouping `(11, 10, 6)`
- The grouping `(1, 11, 06)` is invalid because `"06"` is not a valid code (only `"6"` is valid).

Note: there may be strings that are impossible to decode.

Given a string s containing only digits, return the **number of ways** to **decode** it. If the entire string cannot be decoded in any valid way, return `0`.

The test cases are generated so that the answer fits in a **32-bit** integer.

 

**Example 1:**

**Input:** s = "12"

**Output:** 2

**Explanation:**

"12" could be decoded as "AB" (1 2) or "L" (12).

**Example 2:**

**Input:** s = "226"

**Output:** 3

**Explanation:**

"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

**Example 3:**

**Input:** s = "06"

**Output:** 0

**Explanation:**

"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.

 

**Constraints:**

- `1 <= s.length <= 100`
- `s` contains only digits and may contain leading zero(s).



## solution

首先是你写的劣质回溯哈，内存直接爆了，当然也是没通过

~~~
class Solution {
public:
    //vector<int> path = vector<int>();
    int result = 0;
    void backtracking(string s, int index)
    {
        if(index>=s.size())
        {
            result++;
            return;
        }
        
        if(s[index]=='0') return;

        backtracking(s,index+1);

        if(s[index]=='1' && index+1<s.size())
        {
            backtracking(s,index+2);
        }
        else if(s[index]=='2' && index+1<s.size())
        {
            if(s[index+1]>='0' && s[index+1]<='6')
                backtracking(s,index+2);
        }
    }
    int numDecodings(string s) {
        backtracking(s, 0);
        return result;
    }
};
~~~

我们把思路拓宽一点，这道题其实是一道动态规划题啊你有没有发现？如果题目希望我们返回所有可能的decode我们可能要用回溯去记录每一个结果。但既然题目只需要decode的数量，那我们完全可以用动态规划来写哈。怪不得34%通过率，这个细节真的难扣我去

~~~
class Solution {
public:
    int numDecodings(string s) {
        //vector<vector<int>> result(s.size()+1,vector<int>(s.size()+1,0));
        if(s[0]=='0') return 0;
        vector<int> dp(s.size()+1,0);
        dp[0] = 1;
        dp[1] = 1;

        for(int i=2;i<=s.size();i++)
        {
            if(s[i-1]=='0')
            {
                if(s[i-2]=='1' || s[i-2]=='2') dp[i] = dp[i-2];
                else return 0;
            }
            else if(s[i-2]=='0') dp[i] = dp[i-1];
            else if(s[i-2]=='1') 
            {
                dp[i] = dp[i-1] + dp[i-2];
            }
            else if(s[i-2]=='2')
            {
                //cout<<"haha"<<endl;
                if(s[i-1]<='6')
                {
                    dp[i] = dp[i-1] + dp[i-2];
                    //cout<<"test"<<endl;
                }
                else dp[i] = dp[i-1];
            }
            else dp[i] = dp[i-1];
            //cout<<i<<" "<<dp[i]<<endl;
        }
        return dp[s.size()];
    }
};
~~~

