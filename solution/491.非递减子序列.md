# 491.非递减子序列

## 题目描述

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 

**示例 1：**

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

**示例 2：**

```
输入：nums = [4,4,3,2,1]
输出：[[4,4]]
```



## 题解

为什么我思路已经非常接近了却还是没有写出来？是used数组使用不够熟练嘛？

以下大部分代码都是自己实现的，唯独在使用used数组的时候出现了一些问题。当然我们在做哈希实现的时候除了使用unordered set之外还可以很平常的使用哈希数组。

~~~
class Solution {
public:
    vector<vector<int>> result;
    vector<int> subset;
    void backtracking(vector<int>& nums, int startIndex)
    {
        if(subset.size()>1) result.push_back(subset);
        unordered_set<int> used;
        for(int i=startIndex;i<nums.size();i++)
        { 
            if(!subset.empty() && nums[i]<subset[subset.size()-1]) continue;
            if(used.find(nums[i])!=used.end()) continue;
            subset.push_back(nums[i]);
            used.insert(nums[i]);
            backtracking(nums,i+1);
            subset.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums,0);
        return result;
    }
};
~~~

由于题目条件已经给出nums[i]值在-100到100之间

~~~
class Solution {
public:
    vector<vector<int>> result;
    vector<int> subset;
    void backtracking(vector<int>& nums, int startIndex)
    {
        if(subset.size()>1) result.push_back(subset);
        vector<int> used(201,0);
        for(int i=startIndex;i<nums.size();i++)
        { 
            if(!subset.empty() && nums[i]<subset[subset.size()-1]) continue;
            if(used[100+nums[i]]) continue;
            subset.push_back(nums[i]);
            used[100+nums[i]]++;
            backtracking(nums,i+1);
            subset.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums,0);
        return result;
    }
};
~~~

