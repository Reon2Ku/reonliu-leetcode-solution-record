# 92. reverse linked list 2

## question

Given the `head` of a singly linked list and two integers `left` and `right` where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return *the reversed list*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]
```

**Example 2:**

```
Input: head = [5], left = 1, right = 1
Output: [5]
```

 

**Constraints:**

- The number of nodes in the list is `n`.
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

 

**Follow up:** Could you do it in one pass?



## solution

两次遍历

~~~
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        vector<int> result;
        ListNode* curr = head;
        int le = left;
        while(--le) curr = curr->next;
        ListNode* start = curr;
        int ri = right-left;
        while(ri--) 
        {
            result.push_back(curr->val);
            curr = curr->next;
        }
        result.push_back(curr->val);
        for(int i=result.size()-1;i>=0;i--)
        {
            start->val = result[i];
            start = start->next;
        }
        return head;
    }
};
~~~

一次遍历：自己写的，good job

~~~
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* start;
        ListNode* front;
        int count = 1;
        ListNode* dummyhead = new ListNode(0);
        dummyhead->next = head;
        ListNode* curr = dummyhead;
        while(count<left)
        {
            curr = curr->next;
            count++;
        }
        start = curr;
        ListNode* pre = start;
        curr = curr->next;
        front = curr;

        while(count<=right)
        {
            ListNode* temp = curr->next;
            curr->next = pre;
            pre = curr;
            curr = temp;
            count++;
        }
        start->next = pre;
        front->next = curr;
        return dummyhead->next;

    }
};
~~~

