# 113.路径总和②

## 题目描述

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：[]
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：[]
```

## 题解

公式化做题就是快啊。迭代：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<vector<int>> result;
        stack<TreeNode*> sta;
        stack<vector<int>> staVec;
        stack<int> sumOf;
        if(root==NULL) return result;
        sta.push(root);
        sumOf.push(root->val);
        vector<int> temp;
        temp.push_back(root->val);
        staVec.push(temp);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();sta.pop();
            int sum = sumOf.top();sumOf.pop();
            vector<int> path = staVec.top();staVec.pop();

            if(!node->left&&!node->right)
            {
                if(sum==targetSum)  result.push_back(path);
                continue;
            }
            if(node->left)
            {
                path.push_back(node->left->val);
                staVec.push(path);
                path.pop_back();

                sumOf.push(sum+node->left->val);

                sta.push(node->left);
            }
            if(node->right)
            {
                path.push_back(node->right->val);
                staVec.push(path);
                path.pop_back();

                sumOf.push(sum+node->right->val);

                sta.push(node->right);
            }

        }
        return result;

    }
};
~~~

递归：奇了怪了，明明思路是差不多的，为什么递归比迭代快那么多呢？

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void myPathSum(TreeNode* node,int targetSum,vector<vector<int>>& result,int sum,vector<int>& path)
    {
        if(node==NULL) return;
        if(!node->left&&!node->right)
        {
            if(sum == targetSum) result.push_back(path);
            return;
        }
        if(node->left)
        {
            path.push_back(node->left->val);
            myPathSum(node->left,targetSum,result,sum+node->left->val,path);
            path.pop_back();
        }
        if(node->right)
        {
            path.push_back(node->right->val);
            myPathSum(node->right,targetSum,result,sum+node->right->val,path);
            path.pop_back();
        }
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<vector<int>> result;
        if(root==NULL) return result;
        vector<int> path;
        path.push_back(root->val);
        myPathSum(root,targetSum,result,root->val,path);
        return result;
    }
};
~~~

