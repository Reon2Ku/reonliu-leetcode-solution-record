# 739.每日温度（单调栈思路介绍）

## 题目描述

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`



## 题解

首先是当然过不了超时限制的暴力解：

~~~
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> result;
        for(int i=0;i<temperatures.size()-1;i++)
        {
            for(int j=i+1;j<temperatures.size();j++)
            {
                if(temperatures[j]>temperatures[i])
                {
                    result.push_back(j-i);
                    break;
                }
                if(j==temperatures.size()-1) result.push_back(0);
            }
        }
        result.push_back(0);
        return result;
    }
};
~~~

接下来看单调栈思路：

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。相对于暴力解的O(n^2)表现更好

单调栈的本质是用空间复杂度代价换取时间复杂度代价

首先来看看我自己稍微看了点思路想出来的解吧：

~~~
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> sta;
        vector<int> result(temperatures.size(),0);
        result[0]++;
        sta.push(0);
        for(int i=1;i<temperatures.size();i++)
        {
            while(!sta.empty())
            {
                if(temperatures[i]<=temperatures[sta.top()]) 
                {
                    sta.push(i);
                    break;
                }
                else sta.pop();
            }
            stack<int> tempSta(sta);
            while(!tempSta.empty())
            {
                result[tempSta.top()]++;
                tempSta.pop();
            }
        }
        while(!sta.empty())
        {
            result[sta.top()] = 0;
            sta.pop();
        }
        return result;
    }
};
~~~

然而你自己想的勾石方法依旧是O(n^2)啊牛魔的，看看正常的解法吧。

看了下result数组的更新逻辑自己才终于搞定。就这样，重点是学会单调栈的解题思路，数组更新思路，方便后续同类型题目的解

~~~
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> sta;
        vector<int> result(temperatures.size(),0);
        // result[0]++;
        // sta.push(0);
        for(int i=0;i<temperatures.size();i++)
        {
            if(sta.empty() || temperatures[i]<=temperatures[sta.top()]) 
            {
                sta.push(i);
                continue;
            }
            while(!sta.empty() && temperatures[i]>temperatures[sta.top()])
            {
                result[sta.top()] = i-sta.top();
                sta.pop();
            }
            sta.push(i);
        }
        return result;
    }
};
~~~



