# 1047.删除字符串中的所有相邻重复项

## 题目描述

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

**示例：**

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

## 题解：

首先是自己写的，自己写的和标准答案一模一样，而且时间复杂度仅为O(n)，我真的不知道为什么会耗时370ms

空间复杂度是O（n)用的多我可以理解，时间复杂度真的难以理解

~~~
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> result;
        for(int i=0;i<s.size();i++)
        {
            if(!result.empty())
            {
                if(s[i]==result.top()) result.pop();
                else result.push(s[i]);
            }else result.push(s[i]);
        }
        string str;
        while(!result.empty())
        {
            str = result.top()+str;
            result.pop();
        }
        return str;
    }
};
~~~

接着看下一种，不申请额外的stack而是声明一个string进行操作，省去最后的那一步把stack转换成string的操作。

这种方法下时耗仅为18ms，虽然时间复杂度分析的结果也是O(n)，性能却相差甚远。

推断，能用string代替stack时尽量用string，因为string是已经经过高度优化的stl容器。仅在stack的特性有明显超强优势时才使用stack。

这种方法的空间复杂度仅O(1).

~~~
class Solution {
public:
    string removeDuplicates(string s) {
        string result;
        for(int i=0;i<s.size();i++)
        {
            int size = result.size();
            if(size>0)
            {
                if(s[i]==result[size-1]) result.resize(size-1);
                else result+=s[i];
            }else result+=s[i];
        }
        return result;
    }
};
~~~

