# 209.长度最小的子数组

## 题目描述

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续**

**子数组**

`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。



 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```



## 题解

`````
//暴力解法，时间复杂度为O(n^2)，在leetcode上直接提交会超时
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum = 0;
        int sublenth = 0;//子序列长度
        int result = INT32_MAX;//在后面对比的时候用到的，一开始就把result设置成0的话result会一直是0
        for(int i=0;i<nums.size();i++)
        {
            sum = 0;//重置sum
            for(int j=i;j<nums.size();j++)
            {
                sum += nums[j];
                if(sum>=target)//一定是>=，读好题意
                {
                    sublenth = j-i+1;
                    result = sublenth>result?result:sublenth;
                    break;//只要找到一个那就已经是i开头的最小子序列了，不用再找了。
                }
            }
        }
        return result == INT32_MAX?0:result;
    }
};
`````

`````
//标准解法，疑似所有题解的思路都差不多？
//暴力解法中，需要使用两次for循环，左边界固定不动，右边界动慢慢寻找结果。
//滑动窗口解法中，在右边界找到之后，左边界也动使得sum不足，右边界继续动，保证在一次for循环中就可以逐渐找到最小子序列
//解决此类问题，首先考虑现实生活中遇到类似问题人会怎么解决。暴力解法是偏机器思维的。事实上用人的解法考虑一下就不难找出滑动窗口解法
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum = 0;
        int sublenth = 0;
        int result = INT32_MAX;
        int j = 0;//j代表左边界
        for(int i=0;i<nums.size();i++)//i代表右边界
        {
            sum+=nums[i];
            while(sum>=target)
            {
                sublenth = i-j+1;
                result = sublenth>result?result:sublenth;
                sum-=nums[j++];
            }
        }
        return result == INT32_MAX?0:result;
    }
};
//明明不需要几行代码就可以解决的事情花了我好久
//水平还是不太够，加油吧，每日进步！
`````

