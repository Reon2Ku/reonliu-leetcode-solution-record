# 卡码网102.沉没孤岛

###### 题目描述

给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。



现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。

###### 输入描述

第一行包含两个整数 N, M，表示矩阵的行数和列数。

之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。

###### 输出描述

输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格

###### 输入示例

```
4 5
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
```

###### 输出示例

```
1 1 0 0 0
1 1 0 0 0
0 0 0 0 0
0 0 0 1 1
```

###### 提示信息

![img](https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412144356_69900.png)



将孤岛沉没。



![img](https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412144445_89755.png)



数据范围：

1 <= M, N <= 50。



## 题解

自己想的，哈哈，一做图论题就老是犯低级错误

~~~
#include<iostream>
#include<vector>
using namespace std;

void dfs(const vector<vector<int>>& grid,vector<vector<bool>>& visited,int i, int j,vector<vector<int>>& visitedIndex,bool& flag)
{
    if(grid[i][j]==0 || visited[i][j]) return;
    else 
    {
        visited[i][j]=1;
        visitedIndex[0].push_back(i);
        visitedIndex[1].push_back(j);
    }
    if(flag)
    {
        if(i==0||j==0||i==grid.size()-1||j==grid[0].size()-1)
            flag=false;
    }
    if(i+1<grid.size() && !visited[i+1][j]) dfs(grid,visited,i+1,j,visitedIndex
    ,flag);
    if(j+1<grid[0].size() && !visited[i][j+1]) dfs(grid,visited,i,j+1,visitedIndex
    ,flag);
    if(i-1>=0 && !visited[i-1][j]) dfs(grid,visited,i-1,j,visitedIndex
    ,flag);
    if(j-1>=0 && !visited[i][j-1]) dfs(grid,visited,i,j-1,visitedIndex
    ,flag);

}

int main()
{
    int n,m;
    cin>>n>>m;
    vector<vector<int>> grid(n,vector<int>(m,0));
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            cin>>grid[i][j];
        }
    }

    vector<vector<bool>> visited(n,vector<bool>(m,0));
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(!visited[i][j] && grid[i][j]==1)
            {
                bool flag=true;//真表示该岛为孤岛
                vector<vector<int>> visitedIndex(2,vector<int>());
                dfs(grid,visited,i,j,visitedIndex,flag);
                // for(int f=0;f<visitedIndex.size();f++)
                // {
                //     cout<<visitedIndex[0][f]<<" "<<visitedIndex[1][f]<<endl;
                // }
                
                if(flag)
                {
                    //cout<<visitedIndex.size()<<" "<<visitedIndex[0].size()<<" "<<visitedIndex[1].size()<<endl;
                    //cout<<"孤岛出现了！"<<endl;
                    for(int k=0;k<visitedIndex[0].size();k++)
                    {
                        //cout<<"孤岛在这个坐标！"<<visitedIndex[0][k]<<visitedIndex[1][k]<<endl;
                        grid[visitedIndex[0][k]][visitedIndex[1][k]] = 0;
                    }
                }
                visitedIndex.clear();
            }
        }
    }

    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m-1;j++)
        {
            cout<<grid[i][j]<<" ";
        }
        cout<<grid[i][grid[0].size()-1]<<endl;
    }
}
~~~

