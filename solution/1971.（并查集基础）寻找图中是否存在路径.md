# 1971.（并查集基础）寻找图中是否存在路径

## 题目描述

有一个具有 `n` 个顶点的 **双向** 图，其中每个顶点标记从 `0` 到 `n - 1`（包含 `0` 和 `n - 1`）。图中的边用一个二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和顶点 `vi` 之间的双向边。 每个顶点对由 **最多一条** 边连接，并且没有顶点存在与自身相连的边。

请你确定是否存在从顶点 `source` 开始，到顶点 `destination` 结束的 **有效路径** 。

给你数组 `edges` 和整数 `n`、`source` 和 `destination`，如果从 `source` 到 `destination` 存在 **有效路径** ，则返回 `true`，否则返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png)

```
输入：n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
输出：true
解释：存在由顶点 0 到顶点 2 的路径:
- 0 → 1 → 2 
- 0 → 2
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png)

```
输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
输出：false
解释：不存在由顶点 0 到顶点 5 的路径.
```

 

**提示：**

- `1 <= n <= 2 * 105`
- `0 <= edges.length <= 2 * 105`
- `edges[i].length == 2`
- `0 <= ui, vi <= n - 1`
- `ui != vi`
- `0 <= source, destination <= n - 1`
- 不存在重复边
- 不存在指向顶点自身的边



## 题解

并查集模板：

~~~
class Solution {
public:
    vector<int> father = vector<int>(200000,0);
    int findRoot(int u)
    {
        if(father[u] == u) return u;
        father[u] = findRoot(father[u]);//路径压缩，省略掉大部分的find递归过程。
        return father[u];
        //return father[u] = findRoot(father[u]);简化后的写法，先计算右侧findRoot(father[u])，再将结果赋值给father[u]并且return
    }
    void join(int u,int v)
    {
        int uf = findRoot(u);
        int vf = findRoot(v);
        if(uf == vf) return ;
        else father[uf] = vf; 
    }
    bool sameFather(int u,int v)
    {
        if(findRoot(u)==findRoot(v)) return true;
        else return false;
    }
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        if(source == destination) return true;
        for(int i=0;i<n;i++) father[i] = i;
        for(int i=0;i<edges.size();i++)
        {
            int u = edges[i][0];
            int v = edges[i][1];
            if(sameFather(u,v)) continue;
            else join(u,v);
        }

        return sameFather(source, destination);
    }
};
~~~

还有我自己写的幽默暴力解，内存直接爆炸，根本ac不了

~~~
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        if(source == destination) return true;
        vector<vector<bool>> graph(n,vector<bool>(n,0));
        for(int i=0;i<edges.size();i++)
        {
            graph[edges[i][0]][edges[i][1]] = 1;
            graph[edges[i][1]][edges[i][0]] = 1;
        }
        queue<int> pathQue;
        vector<bool> visited(n,0); 
        pathQue.push(source);
        visited[source] = 1;
        while(!pathQue.empty())
        {
            int curr = pathQue.front();
            cout<<curr<<endl;
            visited[curr] = 1;
            pathQue.pop();
            if(graph[curr][destination]) return true;
            for(int i=0;i<n;i++)
            {
                if(visited[i]) continue;
                if(graph[curr][i]) pathQue.push(i);
            }
        }
        return false;
    }
};
~~~

