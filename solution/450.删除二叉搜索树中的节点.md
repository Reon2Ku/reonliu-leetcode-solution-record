# 450.删除二叉搜索树中的节点

## 题目描述

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

```
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
```

**示例 3:**

```
输入: root = [], key = 0
输出: []
```

## 题解

这道题的核心在于理解删除节点并且把下方节点接上去的过程。

尤其是当目标节点既有左子树又有右子树时该如何实现删减操作

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==NULL) return NULL;
        if(root->val == key)
        {
            if(!root->left&&!root->right)
            {
                delete root;
                return NULL;
            }
            if(!root->left&&root->right)
            {
                auto retNode = root->right;
                delete root;
                return retNode;
            }
            if(!root->right&&root->left)
            {
                auto retNode = root->left;
                delete root;
                return retNode;
            }
            if(root->left&&root->right)
            {
                TreeNode* curr = root->right;
                while(curr->left) curr = curr->left;
                curr->left = root->left;
                TreeNode* temp = root->right;
                delete root;
                return temp;
            }
        }
        if(root->val>key) 
            root->left = deleteNode(root->left,key);
        if(root->val<key)
            root->right = deleteNode(root->right,key);
        return root;
    }
};
~~~

自己写的迭代：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode* curr = root;
        TreeNode* pre = curr;
        while(curr!=NULL)
        {
            if(curr->val>key) 
            {
                pre = curr;
                curr = curr->left;
            }
            else if(curr->val<key) 
            {
                pre = curr;
                curr = curr->right;
            }
            else break; 
        }
        if(curr==NULL) return root;
        if(!curr->left&&!curr->right) 
        {
            if(curr!=root) 
            {
                if(pre->left==curr) pre->left=NULL;
                else if(pre->right==curr) pre->right=NULL;
                delete curr;
                return root;
            }
            else return NULL;
        }
        else if(curr->left&&!curr->right)
        {
            if(curr!=root)
            {
                if(pre->left == curr) pre->left = curr->left;
                else if(pre->right == curr) pre->right = curr->left;
                delete curr;
            }
            else
            {//确保正确释放内存，不然的话直接写else return curr->left就可以了
                TreeNode* result = curr->left;
                delete curr;
                return result;
            } 
            
            return root;
        }
        else if(!curr->left&&curr->right)
        {
            if(curr!=root)
            {
                if(pre->left == curr) pre->left = curr->right;
                else if(pre->right == curr) pre->right = curr->right;
                delete curr;
            }
            else
            {
                TreeNode* result = curr->right;
                delete curr;
                return result;
            } 
            return root;
        }
        else if(curr->left&&curr->right)
        {
            if(curr!=root)
            {
                TreeNode* temp = curr->right;
                while(temp->left!=NULL) temp = temp->left;
                temp->left = curr->left;
                if(pre->left==curr) pre->left = curr->right;
                if(pre->right==curr) pre->right = curr->right;
                delete curr;
                return root;
            }
            else 
            {
                TreeNode* temp = curr->right;
                while(temp->left!=NULL) temp = temp->left;
                temp->left = curr->left;
                TreeNode* result = root->right;
                delete root;
                return result;
            }
            
        }
        return root;
    }
};
~~~

简化版：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode* curr = root;
        TreeNode* pre = curr;
        while(curr!=NULL)
        {
            if(curr->val>key) 
            {
                pre = curr;
                curr = curr->left;
            }
            else if(curr->val<key) 
            {
                pre = curr;
                curr = curr->right;
            }
            else break; 
        }
        if(curr==NULL) return root;
        if(!curr->left&&!curr->right) 
        {
            if(curr!=root) 
            {
                if(pre->left==curr) pre->left=NULL;
                else if(pre->right==curr) pre->right=NULL;
                delete curr;
            }
            else return NULL;
        }
        else if(curr->left&&!curr->right)
        {
            if(curr!=root)
            {
                if(pre->left == curr) pre->left = curr->left;
                else if(pre->right == curr) pre->right = curr->left;
                delete curr;
            }
            else
            {//确保正确释放内存，不然的话直接写else return curr->left就可以了
                TreeNode* result = curr->left;
                delete curr;
                return result;
            } 
        }
        else if(!curr->left&&curr->right)
        {
            if(curr!=root)
            {
                if(pre->left == curr) pre->left = curr->right;
                else if(pre->right == curr) pre->right = curr->right;
                delete curr;
            }
            else
            {
                TreeNode* result = curr->right;
                delete curr;
                return result;
            } 
        }
        else if(curr->left&&curr->right)
        {
            TreeNode* temp = curr->right;
            while(temp->left!=NULL) temp = temp->left;
            temp->left = curr->left;
            if(curr!=root)
            {
                if(pre->left==curr) pre->left = curr->right;
                if(pre->right==curr) pre->right = curr->right;
                delete curr;
            }
            else 
            {
                TreeNode* result = root->right;
                delete root;
                return result;
            }
        }
        return root;
    }
};
~~~

非二叉搜索树的节点删除通用法：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==NULL) return root;
        if(root->val==key)
        {
            if(!root->right) return root->left;//这里其实已经在实现删除key节点的功能了
            //key节点的值会先被替换到某个叶子节点，当递归到叶子节点时，这一句会把这个叶子截掉
            else 
            {//把key节点中的值与其右子树下最左边的节点交换。
                TreeNode* curr = root->right;
                while(curr->left) curr = curr->left;
                swap(root->val,curr->val);
            }
        }

        root->left = deleteNode(root->left,key);
        root->right = deleteNode(root->right,key);
        return root;
    }
};
~~~

