# 349.两个数组的交集

## 题目描述

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的* 

*交集*

 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**示例 2：**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```

 

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`



## 题解

首先是自己写的幽默解法，库函数太好用辣

~~~
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        int vecSize = max(nums1[nums1.size()-1],nums2[nums2.size()-1]);
        vector<int> record;
        for(int i=0;i<=vecSize;i++)
        {
            record.push_back(0);
        }
        for(int i=0;i<nums1.size();i++)
        {
            if(record[nums1[i]]==0)
                record[nums1[i]]++;
        }
        for(int i=0;i<nums2.size();i++)
        {
            if(record[nums2[i]]==1)
                record[nums2[i]]++;
        }
        vector<int> result;
        for(int i=0;i<record.size();i++)
        {
            if(record[i]>1) result.push_back(i);
        }
        return result;
    }
};//O(NlogN)
~~~

自己写的这种算法是采用上一题的思想使用了数组来进行哈希表的建立。如果哈希表的大小是固定并且不会浪费太多空间的，采用数组完全没有问题。但是本题中由于数组数值不确定，建立数组哈希表很可能浪费大量空间。我们接下来看更优的解法：下面的思想在之后的哈希表题目中也会大量运用到

## 思路

这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。

注意题目特意说明：**输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序**

这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。

那么用数组来做哈希表也是不错的选择，例如[242. 有效的字母异位词(opens new window)](https://programmercarl.com/0242.有效的字母异位词.html)

但是要注意，**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**

而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。

**而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：

- std::set
- std::multiset
- std::unordered_set

std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。

思路如图所示：

![set哈希法](https://code-thinking-1253855093.file.myqcloud.com/pics/20220707173513.png)

~~~
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> testSet;
        unordered_set<int> numSet(nums1.begin() , nums1.end());
        for(int eachNum : nums2)//for every num in nums2
        {
            if(numSet.find(eachNum) != numSet.end())
            {
                testSet.insert(eachNum);
            }
        }
        vector<int> resultSet(testSet.begin(),testSet.end());
        return resultSet;
    }
};
~~~

## 拓展

那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。

直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。

不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。

## 后记

本题后面 力扣改了 题目描述 和 后台测试数据，增添了 数值范围：

- 1 <= nums1.length, nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 1000

所以就可以 使用数组来做哈希表了， 因为数组都是 1000以内的。

对应C++代码如下：

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
        int hash[1005] = {0}; // 默认数值为0
        for (int num : nums1) { // nums1中出现的字母在hash数组中做记录
            hash[num] = 1;
        }
        for (int num : nums2) { // nums2中出现话，result记录
            if (hash[num] == 1) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

- 时间复杂度: O(m + n)

- 空间复杂度: O(n)

	和我的方法思路好像差不多？但是直接声明了一个1000的数组，占用更多的内存。

	而我的就是消耗更多时间来节约内存