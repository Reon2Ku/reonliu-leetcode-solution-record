# 463.岛屿的周长

## 题目描述

给定一个 `row x col` 的二维网格地图 `grid` ，其中：`grid[i][j] = 1` 表示陆地， `grid[i][j] = 0` 表示水域。

网格中的格子 **水平和垂直** 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)

```
输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边
```

**示例 2：**

```
输入：grid = [[1]]
输出：4
```

**示例 3：**

```
输入：grid = [[1,0]]
输出：4
```

 

**提示：**

- `row == grid.length`
- `col == grid[i].length`
- `1 <= row, col <= 100`
- `grid[i][j]` 为 `0` 或 `1`



## 题解

这题虽是简单题，但意义在于避免惯性思维。

首先肯定想到的是dfs或者bfs，如下：

~~~
class Solution {
public:
    int count = 0;
    void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j, int& result)
    {
        //count++;
        if(visited[i][j]) return;
        if(grid[i][j]==0) return;
        else visited[i][j] = 1;
        if(i-1<0 || grid[i-1][j]==0) result++;
        else dfs(grid,visited,i-1,j,result);
        if(j-1<0 || grid[i][j-1]==0) result++;
        else dfs(grid,visited,i,j-1,result);
        if(i+1>=grid.size() || grid[i+1][j]==0) result++;
        else dfs(grid,visited,i+1,j,result);
        if(j+1>=grid[0].size() || grid[i][j+1]==0) result++;
        else dfs(grid,visited,i,j+1,result);
    }
    int islandPerimeter(vector<vector<int>>& grid) {
        int result = 0;
        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),0));
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(grid[i][j]==1)
                {
                    dfs(grid,visited,i,j,result);
                }
            }
        }
        //cout<<count<<endl;
        return result;
    }
};
~~~

但是本题不用深搜或者广搜也可以轻松解决：

计算出总的岛屿数量，总的变数为：岛屿数量 * 4

因为有一对相邻两个陆地，边的总数就要减2，如图红线部分，有两个陆地相邻，总边数就要减2（当然不是我想出来的哈，我只会公式化宝丽洁）

~~~
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int island = 0;
        int border = 0;
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(grid[i][j]==1)
                {
                    if (grid[i][j] == 1)
                    {
                    island++; // 统计总的陆地数量
                    // 统计上边相邻陆地
                    if(i - 1 >= 0 && grid[i - 1][j] == 1) border++;
                    // 统计左边相邻陆地
                    if(j - 1 >= 0 && grid[i][j - 1] == 1) border++;
                    // 为什么没统计下边和右边？ 因为避免重复计算
                    }
                }
            }
        }
        return 4*island - 2*border;
    }
};
~~~

