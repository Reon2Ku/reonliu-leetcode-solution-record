# 1254.统计封闭岛屿的数目

## 题目描述

二维矩阵 `grid` 由 `0` （土地）和 `1` （水）组成。岛是由最大的4个方向连通的 `0` 组成的群，封闭岛是一个 `完全` 由1包围（左、上、右、下）的岛。

请返回 *封闭岛屿* 的数目。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png)

```
输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：
灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_4_1610.png)

```
输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
输出：1
```

**示例 3：**

```
输入：grid = [[1,1,1,1,1,1,1],
             [1,0,0,0,0,0,1],
             [1,0,1,1,1,0,1],
             [1,0,1,0,1,0,1],
             [1,0,1,1,1,0,1],
             [1,0,0,0,0,0,1],
             [1,1,1,1,1,1,1]]
输出：2
```

 

**提示：**

- `1 <= grid.length, grid[0].length <= 100`
- `0 <= grid[i][j] <=1`



## 题解

~~~
class Solution {
public:
    void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j,bool& flag)
    {
        if(grid[i][j]==1 || visited[i][j])
            return;
        else visited[i][j] = 1;
        if(flag)
        {
            if(i==0||j==0||i==grid.size()-1||j==grid[0].size()-1)
                flag = false;
        }
        if(i+1<grid.size()&&!visited[i+1][j]) dfs(grid,visited,i+1,j,flag);
        if(j+1<grid[0].size()&&!visited[i][j+1]) dfs(grid,visited,i,j+1,flag);
        if(i-1>=0&&!visited[i-1][j]) dfs(grid,visited,i-1,j,flag);
        if(j-1>=0&&!visited[i][j-1]) dfs(grid,visited,i,j-1,flag);

    }
    int result = 0;//封闭岛屿数目
    int closedIsland(vector<vector<int>>& grid) {
        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),0));
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(grid[i][j]==0&&!visited[i][j])
                {
                    bool flag = true; //为真表示是孤岛
                    dfs(grid,visited,i,j,flag);
                    if(flag)
                    {
                        //cout<<"result++ at"<<i<<" "<<j<<endl;
                        result++;
                    }
                }
            }
        }
        return result;
    }
};
~~~

