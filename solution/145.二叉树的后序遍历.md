# 145.二叉树的后序遍历

## 题目描述

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)

```
输入：root = [1,null,2,3]
输出：[3,2,1]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

## 题解

首先是easy的递归法

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void postTraversal(TreeNode* curr, vector<int>& vec)
    {
        if(curr==nullptr) return;
        postTraversal(curr->left,vec);
        postTraversal(curr->right,vec);
        vec.push_back(curr->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        postTraversal(root,result);
        return result;
    }
};
~~~

接着看迭代法。这里说实话技巧性有点过于强了。

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> myStack;
        vector<int> result;
        if(root == NULL) return result;
        myStack.push(root);
        while(!myStack.empty())
        {
            TreeNode* node = myStack.top();
            result.push_back(node->val);
            myStack.pop();
            if(node->left) myStack.push(node->left);
            if(node->right) myStack.push(node->right);
        }
        reverse(result.begin(),result.end());
        return result;
        
    }
};
~~~

### 后序遍历（迭代法）

再来看后序遍历，先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![前序到后序](https://code-thinking-1253855093.file.myqcloud.com/pics/20200808200338924.png)

**所以后序遍历只需要前序遍历的代码稍作修改就可以了**



然而这种迭代法技巧性太强了，有没有什么逻辑性又强又不需要很强技巧性的迭代法呢？

来看统一风格迭代法

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
vector<int> result;
        stack<TreeNode*> sta;
        if(root==NULL) return result;
        sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            if(node!=NULL)
            {
                sta.pop();
                sta.push(node);
                sta.push(NULL);//标记node节点，表示已访问但未添加到result数组

                if(node->right) sta.push(node->right);
                
                if(node->left) sta.push(node->left);
            }
            else
            {
                sta.pop();
                node = sta.top();
                result.push_back(node->val);
                sta.pop();
            }
        }
        return result;       
    }
};
~~~

从根节点开始，我们既希望利用这个根节点访问到他的左右子节点（如果有的话），有希望最后能够将其放入result集中正确的位置。所以我们一开始将根节点放入栈中之后要做几件事：①把他取出来②把他的右孩子放进栈③把他自己放进栈④加入一个null节点表示我们已经使用这个root访问过了左右子节点⑤把他的左孩子放入栈。

如此一来我们就形成了一个右中左的栈，先进后出的原则会将输出结果顺序颠倒变为左中右实现中序遍历

以中序遍历为例，我们需要在前序遍历中做的事（构建右左中，颠倒后变为中左右）以及后序遍历中做的事（构建中右左，颠倒后变为左右中）其实是类似的，可以像递归法中仅更改代码中少量代码的顺序即可实现。