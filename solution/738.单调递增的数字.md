# 738.单调递增的数字

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

 

**示例 1:**

```
输入: n = 10
输出: 9
```

**示例 2:**

```
输入: n = 1234
输出: 1234
```

**示例 3:**

```
输入: n = 332
输出: 299
```

 

**提示:**

- `0 <= n <= 109`



## 题解

爽啊，又是自己想出来的，成就感满满

~~~
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        if(n<10) return n;
        int curr = n;
        vector<int> originalNum;
        while(curr>0)
        {
            originalNum.push_back(curr%10);
            curr/=10;
        }
        reverse(originalNum.begin(),originalNum.end());
        while(true)
        {
            bool flag = true;//flag为true则全升序
            for(int i=1;i<originalNum.size();i++)
            {
                //cout<<originalNum[i-1]<<endl;
                if(flag)
                {
                    if(originalNum[i]>=originalNum[i-1])
                        continue;
                    else 
                    {
                        originalNum[i-1]--;
                        //cout<<originalNum[i-1]<<endl;
                        flag = false;
                    }
                }
                if(!flag)
                {
                    originalNum[i] = 9;
                }
            }
            //cout<<originalNum[originalNum.size()-1]<<endl<<endl;
            if(flag) break;
        }
        
        reverse(originalNum.begin(),originalNum.end());
        int result = 0;
        for(int i=0;i<originalNum.size();i++)
        {
            result += originalNum[i] * pow(10,i);
        }

        return result;
    }
};
~~~

优化了一下，把两句reverse给优化掉了

~~~
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        if(n<10) return n;
        int curr = n;
        vector<int> originalNum;
        while(curr>0)
        {
            originalNum.push_back(curr%10);
            curr/=10;
        }
        //reverse(originalNum.begin(),originalNum.end());
        while(true)
        {
            bool flag = true;//flag为true则全升序
            for(int i=originalNum.size()-1;i>0;i--)
            {
                //cout<<originalNum[i-1]<<endl;
                if(flag)
                {
                    if(originalNum[i]<=originalNum[i-1])
                        continue;
                    else 
                    {
                        originalNum[i]--;
                        //cout<<originalNum[i-1]<<endl;
                        flag = false;
                    }
                }
                if(!flag)
                {
                    originalNum[i-1] = 9;
                }
            }
            //cout<<originalNum[originalNum.size()-1]<<endl<<endl;
            if(flag) break;
        }
        
        //reverse(originalNum.begin(),originalNum.end());
        int result = 0;
        for(int i=0;i<originalNum.size();i++)
        {
            result += originalNum[i] * pow(10,i);
        }

        return result;
    }
};
~~~

