# 417.太平洋大西洋水流问题

## 题目描述

有一个 `m × n` 的矩形岛屿，与 **太平洋** 和 **大西洋** 相邻。 **“太平洋”** 处于大陆的左边界和上边界，而 **“大西洋”** 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 `m x n` 的整数矩阵 `heights` ， `heights[r][c]` 表示坐标 `(r, c)` 上单元格 **高于海平面的高度** 。

岛上雨水较多，如果相邻单元格的高度 **小于或等于** 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标 `result` 的 **2D 列表** ，其中 `result[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 流动 **既可流向太平洋也可流向大西洋** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)

```
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

**示例 2：**

```
输入: heights = [[2,1],[1,2]]
输出: [[0,0],[0,1],[1,0],[1,1]]
```

 

**提示：**

- `m == heights.length`
- `n == heights[r].length`
- `1 <= m, n <= 200`
- `0 <= heights[r][c] <= 105`



## 题解

自己想了老半天，哎哎

~~~
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        vector<vector<bool>> pacific(m,vector<bool>(n,0));
        vector<vector<bool>> atlantic(m,vector<bool>(n,0));

        queue<vector<int>> queuePaci;
        queue<vector<int>> queueAtlan;
        queuePaci.push({0,0});
        queueAtlan.push({m-1,n-1});

        while(!queuePaci.empty())
        {
            int i=queuePaci.front()[0];
            int j=queuePaci.front()[1];
            pacific[i][j]=1;
            //cout<<"current index:"<<i<<" "<<j<<endl;
            queuePaci.pop();
            if(i+1<m&&!pacific[i+1][j])
            {
                if(j==0||heights[i+1][j]>=heights[i][j])
                {
                    queuePaci.push({i+1,j});
                    pacific[i+1][j]=1;
                }
            }
            if(j+1<n&&!pacific[i][j+1])
            {
                if(i==0||heights[i][j+1]>=heights[i][j]) 
                {
                    queuePaci.push({i,j+1});
                    pacific[i][j+1]=1;
                } 
            }
            if(i-1>=0&&!pacific[i-1][j])
            {
                if(heights[i-1][j]>=heights[i][j])
                {
                    queuePaci.push({i-1,j});
                    pacific[i-1][j]=1;
                }
                    
            }
            if(j-1>=0&&!pacific[i][j-1])
            {
                if(heights[i][j-1]>=heights[i][j])
                {
                    queuePaci.push({i,j-1});
                    pacific[i][j-1]=1;
                }
            }
        }
        //cout<<"——————————————————————————————"<<endl;
        while(!queueAtlan.empty())
        {
            int i=queueAtlan.front()[0];
            int j=queueAtlan.front()[1];
            atlantic[i][j]=1;
            //cout<<"current index:"<<i<<" "<<j<<endl;
            queueAtlan.pop();
            if(i-1>=0&&!atlantic[i-1][j])
            {
                if(j==n-1||heights[i-1][j]>=heights[i][j])
                {
                    queueAtlan.push({i-1,j});
                    atlantic[i-1][j]=1;
                }
                    
            }
            if(j-1>=0&&!atlantic[i][j-1])
            {
                if(i==m-1||heights[i][j-1]>=heights[i][j]) 
                {
                    queueAtlan.push({i,j-1});
                    atlantic[i][j-1]=1;
                }
                    
            }
            if(i+1<m&&!atlantic[i+1][j])
            {
                if(heights[i+1][j]>=heights[i][j])
                {
                    queueAtlan.push({i+1,j});
                    atlantic[i+1][j]=1;
                }
                    
            }
            if(j+1<n&&!atlantic[i][j+1])
            {
                if(heights[i][j+1]>=heights[i][j]) 
                {
                    queueAtlan.push({i,j+1});
                    atlantic[i][j+1]=1;
                }
                    
            }
        }


        vector<vector<int>> result;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(pacific[i][j] && atlantic[i][j]) result.push_back({i,j});
            }
        }
        return result;
    }
};
~~~

