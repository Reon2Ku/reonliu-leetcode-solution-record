# 106.从中序与后序遍历序列构造二叉树

## 题目描述

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

**示例 2:**

```
输入：inorder = [-1], postorder = [-1]
输出：[-1]
```

## 题解

照着代码随想录的思路敲的，原创部分不多。这题的核心点在于你对递归的使用依旧不算特别熟练，而且如何对中序和后序数组进行分割并将分割后的数组传递给递归。

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* traversal(vector<int>& inorder,vector<int>& postorder)
    {
        if(postorder.size()==0) return NULL;

        int rootValue = postorder[postorder.size()-1];
        TreeNode* root = new TreeNode(rootValue);

        if (postorder.size()==1) return root;

        int index = 0;
        for(;index<inorder.size();index++)
        {
            if(inorder[index]==rootValue) break;
        }

        vector<int> inorderleft(inorder.begin(),inorder.begin()+index);//左闭右开
        vector<int> inorderright(inorder.begin()+index+1,inorder.end());

        vector<int> postorderleft(postorder.begin(),postorder.begin()+inorderleft.size());//左闭右开
        vector<int> postorderright(postorder.begin()+inorderleft.size(),postorder.end()-1);

        root->left = buildTree(inorderleft,postorderleft);
        root->right = buildTree(inorderright,postorderright);

        return root;

    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(postorder.size()==0||inorder.size()==0) return NULL;
        return traversal(inorder,postorder);
    }
};
~~~

以上的解法性能很差，因为你要新声明很多新的数组导致时间空间开销大。

下一阶段尝试自己不声明新数组而是通过找下标的方式去分割数组。

自己还是写不出来，又看答案了

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* traversal(vector<int>& inorder,vector<int>& postorder,int inBegin,int inEnd,int postBegin,int postEnd)
    {
        if(postBegin == postEnd) return NULL;

        int rootValue = postorder[postEnd-1];
        TreeNode* root = new TreeNode(rootValue);

        if(postEnd-postBegin==1) return root;//叶子节点

        int index;
        for(index=inBegin;index<inEnd;index++)
        {
            if(inorder[index]==rootValue) break;
        }

        //全部都是左闭右开
        int leftinbegin = inBegin;
        int rightinbegin = index+1;
        int leftinend = index;
        int rightinend = inEnd;

        int leftpostbegin = postBegin;
        int rightpostbegin = postBegin+index-inBegin;
        int leftpostend = postBegin+index-inBegin;
        int rightpostend = postEnd-1;

        root->left = traversal(inorder,postorder,leftinbegin,leftinend,leftpostbegin,leftpostend);
        root->right = traversal(inorder,postorder,rightinbegin,rightinend,rightpostbegin,rightpostend);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(inorder.size()==0||postorder.size()==0) return NULL;
        return traversal(inorder,postorder,0,inorder.size(),0,postorder.size());
    }
};
~~~

