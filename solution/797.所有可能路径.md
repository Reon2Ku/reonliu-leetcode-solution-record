# 797.所有可能路径

给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出从节点 `0` 到节点 `n-1` 的所有路径并输出（**不要求按特定顺序**）

 `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

```
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)

```
输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

 

**提示：**

- `n == graph.length`
- `2 <= n <= 15`
- `0 <= graph[i][j] < n`
- `graph[i][j] != i`（即不存在自环）
- `graph[i]` 中的所有元素 **互不相同**
- 保证输入为 **有向无环图（DAG）**



## 题解

一半是看公式题解的，另一半核心代码是自己想的。

深度优先搜索和回溯算法其实蛮相似的。

不如说回溯算法就是深度优先搜索的一种特例

~~~
class Solution {
public:
    vector<vector<int>> result;//符合条件的路径
    vector<int> path;//0到终点的路径
    //x当前遍历到的节点
    //graph当前存的图
    //n:终点
    void dfs(const vector<vector<int>>& graph, int x, int n)
    {
        //递归终止条件？
        if(x==n)//if找到一条符合条件的路径
        {
            //cout<<"go into 终止条件"<<endl;
            result.push_back(path);
            return;
        }
        for (int i = 0; i < graph[x].size(); i++) 
        { // 遍历节点x链接的所有节点
            path.push_back(graph[x][i]); // 遍历到的节点加入到路径中来
            dfs(graph, graph[x][i], n); // 进入下一层递归
            path.pop_back(); // 回溯，撤销本节点
        }
    }
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        path.push_back(0);
        dfs(graph,0,graph.size()-1);
        return result;
    }
};
~~~



接下来看ACM情景下的代码写法，因为图论往往涉及大量的数据读取，而leetcode中仅包含核心代码，不利于笔面试做题。

~~~
using namespace std;
#include <iostream>
#include <vector>

vector<vector<int>> result;
vector<int> path;

void dfs(const vector<vector<int>>& graph, int x, int n)
{
    if(x==n)
    {
        //cout<<"x:"<<x<<"n:"<<n<<endl;
        result.push_back(path);
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(graph[x][i]==1)
        {
            path.push_back(i);
            dfs(graph, i, n);
            path.pop_back();
        }
    }
}

int main()
{
    int n,m,s,t;
    cin>>n>>m;

    vector<vector<int>> graph(n+1,vector<int>(n+1,0));

    while(m--)
    {
        cin>>s>>t;
        graph[s][t] = 1;
    }
    path.push_back(1);
    dfs(graph, 1, n);
    if(result.size()==0) cout<<-1;
    for(int i=0;i<result.size();i++)
    {
        for(int j=0;j<result[i].size();j++)
        {
            if(j!=result[i].size()-1)
            {
                cout<<result[i][j]<<" ";
            }
            else cout<<result[i][j];
            //cout<<result[i][j]<<" ";
        }
        cout<<endl;
    }
}


~~~

