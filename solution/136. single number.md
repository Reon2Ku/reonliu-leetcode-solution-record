# 136. single number

## question

Given a **non-empty** array of integers `nums`, every element appears *twice* except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

 

**Example 1:**

**Input:** nums = [2,2,1]

**Output:** 1

**Example 2:**

**Input:** nums = [4,1,2,1,2]

**Output:** 4

**Example 3:**

**Input:** nums = [1]

**Output:** 1

 

**Constraints:**

- `1 <= nums.length <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`
- Each element in the array appears twice except for one element which appears only once.



## solution

宝丽洁

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        nums.push_back(-1);
        for(int i=0;i<nums.size()-1;i+=2)
        {
            if(nums[i]!=nums[i+1]) return nums[i];
        }
        return -1;
    }
};
~~~

搞笑解

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> myMap;
        for(int i=0;i<nums.size();i++)
        {
            if(myMap.find(nums[i])==myMap.end())
            {
                myMap.insert({nums[i],1});
            }
            else myMap[nums[i]]++;
        }

        for(auto it = myMap.begin();it!=myMap.end();it++)
        {
            if(it->second == 1) return it->first;
        }
        return 0;
    }
};
~~~

练习set用的，虽然也是垃圾算法

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        set<int> mySet;
        for(int i=0;i<nums.size();i++)
        {
            if(mySet.find(nums[i])==mySet.end())
            {
                mySet.insert(nums[i]);
            }
            else mySet.erase(nums[i]);
        }
        //auto it = mySet.begin();
        for(int num: mySet)
        {
            return num;
        }
        return 0;
    }
};
~~~

这题的垃圾解法真的很多。我们来看正规一点的，时间复杂度是O(n), 空间复杂度O(1)

使用异或运算：

什么是异或？a 异或 b，将a和b的每一位单独作比较，如果a==b返回0， a!=b返回 1

**示例计算**：

- `5 ⊕ 3 = ?`

  - 5 的二进制：`0101`

  - 3 的二进制：`0011`

  - 逐位比较：

    ```
    0 1 0 1   (5)
    ⊕ ⊕ ⊕ ⊕
    0 0 1 1   (3)
    -----------
    0 1 1 0   (6)  → 结果为 6
    ```

异或有几个重要的性质：

a 异或 a = 0

a 异或 0 = a

异或运算满足交换律和结合率。

因此刻意将所有相同的元素交换结合异或计算得0， 剩下最后一个单独的数异或0等于自身

对于这道题，要找到唯一的single元素，只需将所有元素进行异或运算，得到的就是单独的那个值

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for(int num : nums)
        {
            result = result^num;
        }
        return result;
    }
};
~~~

师承137，那么每个数字出现n次，找其中具体的一个single number的解也就一目了然了，而不是单纯的靠异或运算特性击败136，出现n次则total%n

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(int i=0;i<32;i++)
        {
            int total = 0;
            for(int num:nums)
            {
                total += (num>>i) & 1;
            }
            if(total%2)
            {
                ans |= (1<<i);
            }
        }
        return ans;
    }
};
~~~



