# 131.分割回文串

## 题目描述

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 

**回文串**

 。返回 `s` 所有可能的分割方案。



 

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```





## 题解

好难啊，难得快要晕倒了，明明盯着看了半天还是好难啊

一看答案好简单，自己一写好困难。判断是否是回文串的逻辑自己到还写得出，如何切割子串遍历根本想不到。希望之后遇到类似的题目能有一个不错的参考，不至于完全没有头绪吧。

~~~
class Solution {
public:
    bool isReverse(const string& str, int start, int end)//判断是否是回文字符串
    {
        for(int i=0;i<(end-start+1)/2;i++)
        {
            if(str[start+i]!=str[end-i]) return false;
        }
        return true;
    }
    vector<vector<string>> result;
    vector<string> path;

    void backtracking(const string& s, int startIndex)
    {
        if(startIndex>=s.size())//这里也可以用==。实际上startIndex作为切割线，一旦切割线到达了字符串末尾，说明已经可以结束递归了，而且找到了一组合适的切割路径。
        {
            result.push_back(path);
            return;
        }

        for(int i = startIndex;i<s.size();i++)
        {
            if(isReverse(s,startIndex,i))
            {
                string substring = s.substr(startIndex,i-startIndex+1);
                path.push_back(substring);
            }
            else continue;
            backtracking(s,i+1);//只有找到了回文字符串才会递归入下一层。
            path.pop_back();
        }
    }
    vector<vector<string>> partition(string s) {
        backtracking(s,0);
        return result;
    }
};
~~~

想要对代码进行逻辑优化，需要用到动态规划思想。学完那里之后重做。