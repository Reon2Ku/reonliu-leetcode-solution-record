# 51.N皇后

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

 

**提示：**

- `1 <= n <= 9`



## 题解

我天呀，真的和我的思路非常接近了。但我并不算完全靠自己写出来的。

回溯的终止条件，回溯递归函数的参数都有所参考卡码。

你可以更相信自己一点，这道题的70%都可以说是你解决的了

~~~
class Solution {
public:
    vector<vector<string>> result;
    void backtracking(int row,int n, vector<string>& path, vector<bool>& column,vector<bool>& left,vector<bool>& right)
    {
        if(row >= n)
        {
            result.push_back(path);
            return;
        }
        for(int j=0;j<n;j++)
        {
            if(column[j] ||left[row+j] ||right[row+n-j-1])
            {
                continue;
            }
            else
            {
                path[row][j] = 'Q';
                column[j] = 1;
                left[row+j] = 1;
                right[row+n-j-1] = 1;
                backtracking(row+1,n,path,column,left,right);
                path[row][j] = '.';
                column[j] = 0;
                left[row+j] = 0;
                right[row+n-j-1] = 0;
            }
        }

    }
    vector<vector<string>> solveNQueens(int n) {
        vector<bool> column(n,0);
        vector<bool> left(2*n-1,0);
        vector<bool> right(2*n-1,0);
        vector<string> path(n,string(n,'.'));
        backtracking(0,n,path,column,left,right);
        return result;
    }
};
~~~

