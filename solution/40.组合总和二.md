# 40.组合总和二

## 题目描述

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```



## 题解

除了那一句神奇的剪枝魔法之外都是自己写的。

这里其实要求我们对于这个所谓的startIndex的含义有一些更深层次的理解

startIndex其实指的是树的深度

这块比较抽象，如图：

![40.组合总和II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png)

有这张图辅助理解就明白这里的去重魔法是怎么一回事了

~~~
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    int sum = 0;
    void backtracking(vector<int>& candidates, int target, int startIndex)
    {
        if(sum==target)
        {
            if(find(result.begin(),result.end(),path)!=result.end()) return;
            result.push_back(path);
            return;
        }
        for(int i=startIndex;i<candidates.size()&&sum+candidates[i]<=target;i++)
        {
            if (i > startIndex && candidates[i] == candidates[i - 1]) {
                continue;
            }//我去，神奇的剪枝魔法！！！
            path.push_back(candidates[i]);
            sum+=candidates[i];
            backtracking(candidates, target, i+1);
            sum-=candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        backtracking(candidates, target, 0);
        return result;
    }
};
~~~



我雷啊禁止重复读取操作这么复杂？

~~~
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;

    int sum = 0;
    void backtracking(vector<int>& candidates, int target, int startIndex, vector<bool>& used)
    {
        if(sum==target)
        {
            if(find(result.begin(),result.end(),path)!=result.end()) return;
            result.push_back(path);
            return;
        }
        for(int i=startIndex;i<candidates.size()&&sum+candidates[i]<=target;i++)
        {
            if (i>0 && candidates[i] == candidates[i - 1] && used[i-1]==false) {
                continue;
            }
            path.push_back(candidates[i]);
            sum+=candidates[i];
            used[i] = true;
            backtracking(candidates, target, i+1, used);
            used[i] = false;
            sum-=candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(),false);
        sort(candidates.begin(),candidates.end());
        backtracking(candidates, target, 0, used);
        return result;
    }
};
~~~

