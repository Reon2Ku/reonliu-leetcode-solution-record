# 108.将有序数组转化为平衡二叉搜索树

## 题目描述

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 

平衡

 二叉搜索树。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

## 题解

自己敲得

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.begin()==nums.end()) return NULL;
        int mid = nums.size()/2;
        TreeNode* node = new TreeNode(nums[mid]);
        vector<int> leftNums(nums.begin(),nums.begin()+mid);
        vector<int> rightNums(nums.begin()+mid+1,nums.end());
        node->left = sortedArrayToBST(leftNums);
        node->right = sortedArrayToBST(rightNums);
        return node;
    }
};
~~~

自己敲得另一版，其实已经非常接近正确结果了，就差一个等号

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mySort(vector<int>& nums,int left,int right)
    {
        if(left>right) return NULL;//这里一开始敲的left>=right，会无限递归栈溢出。改成>编译通过。还是递归结束条件没有考虑清楚
        int mid = (left+right)/2;
        TreeNode* node = new TreeNode(nums[mid]);

        node->left = mySort(nums,left,mid-1);
        node->right = mySort(nums,mid+1,right);
        return node;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return mySort(nums,0,nums.size()-1);
    }
};
~~~

迭代法。你自己不能动动脑子？就知道看答案

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.begin()==nums.end()) return NULL;

        TreeNode* root = new TreeNode(nums[(nums.size()-1)/2]);
        queue<TreeNode*> queNode;
        queue<int> index;
        index.push(0);index.push(nums.size()-1);
        queNode.push(root);

        while(!queNode.empty())
        {
            TreeNode* node = queNode.front();queNode.pop();
            int left = index.front();index.pop();
            int right = index.front();index.pop();
            int mid = (left+right)/2;

            node->val = nums[mid];

            if(left<mid)
            {
                node->left = new TreeNode(0);
                index.push(left);
                index.push(mid-1);
                queNode.push(node->left);
            }
            if(right>mid)
            {
                node->right = new TreeNode(0);
                index.push(mid+1);
                index.push(right);
                queNode.push(node->right);
            }
        }
        return root;
    }
};
~~~

