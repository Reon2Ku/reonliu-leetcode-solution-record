# 763.划分字母区间

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

 

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

**示例 2：**

```
输入：s = "eccbbbbdec"
输出：[10]
```

 

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

## 题解

哎哎又是自己想的，我觉得我牛逼坏了

~~~
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> result;
        if(s.size()==0) return result;
        vector<vector<int>> record(27, vector<int>(2, -1));
        for(int i=0;i<s.size();i++)
        {
            int index = s[i] - 'a';
            if(record[index][0]<0) 
            {
                record[index][0] = i;
                record[index][1] = i;
            }
            else
            {
                record[index][1] = i;
            }
        }
        int column = 0;
        sort(record.begin(),record.end(),[column](const vector<int>& a, const vector<int>& b)
        {
            if(a[0]==b[0]) return a[1]<b[1];
            return a[0]<b[0];
        });
        vector<int> curr = record[0];
        for(int i=1;i<record.size();i++)
        {
            //cout<<record[i][0]<<"  "<<record[i][1]<<endl;
            if(record[i][0]<0) continue;
            else if(curr[0]<0) 
            {
                curr = record[i];
                continue;
            }

            if(record[i][0]<curr[1]) 
            {
                if(record[i][1]>curr[1]) curr[1] = record[i][1];
            }
            else
            {
                result.push_back(curr[1]-curr[0]+1);
                curr = record[i];
            }
        }
        result.push_back(curr[1]-curr[0]+1);
        return result;
    }
};
~~~

