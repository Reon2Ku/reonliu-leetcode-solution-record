# 347.前K个高频元素

## 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

 

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

 

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。



## 题解

不枉我辛苦思考2h，中等题也做到比较优的解了，虽然代码观感比较勾石，不过时间复杂度还是非常的美丽，8ms击败82%，欸。

没想到自己想的意外的和标准答案差不太多。虽然比较函数式gpt帮忙写的。

~~~
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<pair<int,int>> res;
        unordered_map<int,int> myMap;
        for(int i=0;i<nums.size();i++)
        {
            auto it = myMap.find(nums[i]);
            if(it!=myMap.end())
            {
                it->second++;
            }
            else myMap.insert(make_pair(nums[i],1));
        }
        for(auto it=myMap.begin();it!=myMap.end();++it)
        {
            res.push_back(make_pair(it->first,it->second));
        }
        sort(res.begin(),res.end(),[](const auto&lhs,const auto& rhs){
            return lhs.second >= rhs.second;
        });
        res.resize(k);
        vector<int> result;
        for(int i=0;i<k;i++)
        {
            result.push_back(res[i].first);
        }
        return result;
    }
};
~~~

接下来尝试使用另外一种思路，使用小顶堆仅维护最大的   k个元素。priority_queue<type1,type2,比较函数>；

priority_queue加上自己写的比较函数可以实现小顶堆或者大顶堆，这种写法可以好好记一下，以后可以考虑。

欸，时间空间复杂度还不如我呢（嚣张个头到头来关键比较部分还不是gpt教的）

~~~
class Solution {
public:
    class myComparision
    {
        public:
            bool operator()(const pair<int,int>& lhs,const pair<int,int>& rhs)
            {
                return lhs.second>rhs.second;
            }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> myMap;
        for(int i=0;i<nums.size();i++)
        {
            myMap[nums[i]]++;
        }

        priority_queue<pair<int,int>,vector<pair<int,int>>,myComparision> pri_que;
        for(auto it = myMap.begin();it!=myMap.end();++it)
        {
            pri_que.push(*it);
            if(pri_que.size()>k) pri_que.pop();
        }

        vector<int> result;
        for(int i=0;i<k;i++)
        {
            result.push_back(pri_que.top().first);
            pri_que.pop();
        }
        return result;
    }
};
~~~

## 拓展

大家对这个比较运算在建堆时是如何应用的，为什么左大于右就会建立小顶堆，反而建立大顶堆比较困惑。

确实 例如我们在写快排的cmp函数的时候，`return left>right` 就是从大到小，`return left<right` 就是从小到大。

优先级队列的定义正好反过来了，可能和优先级队列的源码实现有关（我没有仔细研究），我估计是底层实现上优先队列队首指向后面，队尾指向最前面的缘故！



## 思路

这道题目主要涉及到如下三块内容：

1. 要统计元素出现频率
2. 对频率排序
3. 找出前K个高频元素

首先统计元素出现的频率，这一类的问题可以使用map来进行统计。

然后是对频率进行排序，这里我们可以使用一种 容器适配器就是**优先级队列**。

什么是优先级队列呢？

其实**就是一个披着队列外衣的堆**，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。

而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？

缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。

什么是堆呢？

**堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。

所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。

本题我们就要使用优先级队列来对部分频率进行排序。

为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

此时要思考一下，是使用小顶堆呢，还是大顶堆？

有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。

那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。

而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？

**所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。**

寻找前k个最大元素流程如图所示：（图中的频率只有三个，所以正好构成一个大小为3的小顶堆，如果频率更多一些，则用这个小顶堆进行扫描）

![347.前K个高频元素](https://code-thinking.cdn.bcebos.com/pics/347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.jpg)