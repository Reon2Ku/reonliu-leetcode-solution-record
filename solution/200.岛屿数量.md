# 200.岛屿数量

## 题目描述

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```



## 题解

核心点还是在于想到使用visited数组解决此问题。

以下是自己想的深度优先遍历方法

~~~
class Solution {
public:
    void dfs(const vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j)
    {
        if(visited[i][j]==1) return;
        if(grid[i][j]=='1') visited[i][j] = 1;
        else return;
        if(i+1<grid.size()) dfs(grid,visited,i+1,j);
        if(j+1<grid[0].size()) dfs(grid,visited,i,j+1);
        if(i-1>=0) dfs(grid,visited,i-1,j);
        if(j-1>=0) dfs(grid,visited,i,j-1);
    }
    
    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0) return 0;
        int result = 0;
        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),0));
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(!visited[i][j] && grid[i][j]=='1')
                {
                    dfs(grid, visited, i, j);
                    //cout<<"i,j:"<<i<<","<<j<<endl;
                    result++;
                }
            }
        }
        return result;
    }
};
~~~



ACM模式写法：

哈哈，我突然发现了ACM模式的摸鱼写法。

说到底，ACM模式的目的就是让你学会如何读取输入正确输出的

~~~
#include <iostream>
#include <vector>
using namespace std;

void dfs(const vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j)
    {
        if(visited[i][j]==1) return;
        if(grid[i][j]=='1') visited[i][j] = 1;
        else return;
        if(i+1<(int)grid.size()) dfs(grid,visited,i+1,j);
        if(j+1<(int)grid[0].size()) dfs(grid,visited,i,j+1);
        if(i-1>=0) dfs(grid,visited,i-1,j);
        if(j-1>=0) dfs(grid,visited,i,j-1);
    }

int numIslands(vector<vector<char>>& grid) {
    if(grid.size()==0) return 0;
    int result = 0;
    vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),0));
    for(int i=0;i<(int)grid.size();i++)
    {
        for(int j=0;j<(int)grid[0].size();j++)
        {
            if(!visited[i][j] && grid[i][j]=='1')
            {
                dfs(grid, visited, i, j);
                //cout<<"i,j:"<<i<<","<<j<<endl;
                result++;
            }
        }
    }
    return result;
}

int main()
{
    int length,width;
    cin>>length>>width;
    vector<vector<char>> grid(length,vector<char>(width,'0'));
    for(int i=0;i<length;i++)
    {
        for(int j=0;j<width;j++)
        {
            cin>>grid[i][j];
        }
    }
    //cout<<numIslands(grid);
    // for(int i=0;i<length;i++)
    // {
    //     for(int j=0;j<width;j++)
    //     {
    //         cout<<grid[i][j];
    //     }
    //     cout<<endl;
    // }
    cout<<numIslands(grid);
}


~~~

自己写的广度优先：

~~~
class Solution {
public:
    // void dfs(const vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j)
    // {
    //     if(visited[i][j]==1) return;
    //     if(grid[i][j]=='1') visited[i][j] = 1;
    //     else return;
    //     if(i+1<grid.size() && !visited[i+1][j]) dfs(grid,visited,i+1,j);
    //     if(j+1<grid[0].size() && !visited[i][j+1]) dfs(grid,visited,i,j+1);
    //     if(i-1>=0 && !visited[i-1][j]) dfs(grid,visited,i-1,j);
    //     if(j-1>=0 && !visited[i][j-1]) dfs(grid,visited,i,j-1);
    // }
    
    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0) return 0;
        int result = 0;
        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),0));
        

        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(!visited[i][j] && grid[i][j]=='1')
                {
                    queue<pair<int,int>> que;
                    que.push(make_pair(i,j));
                    while(!que.empty())
                    {
                        int s = que.front().first;
                        int t = que.front().second;
                        visited[s][t] = 1;
                        if(s+1<grid.size() && !visited[s+1][t] && grid[s+1][t]=='1') 
                        {
                            que.push(make_pair(s+1,t));
                            visited[s+1][t]=1;
                        }
                        if(t+1<grid[0].size() && !visited[s][t+1] && grid[s][t+1]=='1')
                        {
                            que.push(make_pair(s,t+1));
                            visited[s][t+1]=1;
                        }
                        if(s-1>=0 && !visited[s-1][t] && grid[s-1][t]=='1')
                        {
                            que.push(make_pair(s-1,t));
                            visited[s-1][t]=1;
                        } 
                        if(t-1>=0 && !visited[s][t-1] && grid[s][t-1]=='1') 
                        {
                            que.push(make_pair(s,t-1));
                            visited[s][t-1];
                        }
                        //cout<<"test performance："<<s<<" "<<t<<endl;
                        que.pop();
                    }
                    //cout<<"i,j"<<i<<","<<j<<endl;
                    result++;
                    // for(int i=0;i<visited.size();i++)
                    // {
                    //     for(int j=0;j<visited[0].size();j++)
                    //     {
                    //         cout<<visited[i][j]<<" ";
                    //     }
                    //     cout<<endl;
                    // }
                }
            }
        }
        return result;
    }
};
~~~

其实广度优先就是用先进先出的queue在存储节点。

而深度优先就是使用递归的写法。

感觉用stack来存节点的话也是深度优先啊