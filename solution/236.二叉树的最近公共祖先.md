# 236.二叉树的最近公共祖先

## 题目描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

## 题解

自己完全想不到呢，看了一遍官方答案之后有点理解这个过程了。实际上就是，使用后序遍历，当遍历到叶子节点时，如果叶子节点不是目标节点就把叶子节点更新成NULL，如果叶子节点是目标节点就把叶子节点的上一层节点更新为目标节点的值，如果左右子节点都是目标节点就把当前节点传给上一层，这样子两个目标节点会在某处汇聚之后返回公共节点并且逐层传递给root，最后返回该公共节点

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL || root == p||root==q) return root;
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);

        if(left!=NULL&&right!=NULL) return root;
        else if(left==NULL&&right!=NULL) return right;
        else if(left!=NULL&&right==NULL) return left;
        else return NULL;
    }
};
~~~

精简一下逻辑

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL || root == p||root==q) return root;
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);

        if(left!=NULL&&right!=NULL) return root;
        else if(left==NULL) return right;
        else return left;
    }
};
~~~

自己写的迭代：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        stack<TreeNode*> sta;
        sta.push(root);
        TreeNode* myP = NULL;
        TreeNode* myQ = NULL;
        while(!sta.empty())
        {
            TreeNode* node = sta.top();sta.pop();
            if(node!=NULL)
            {
                sta.push(node);sta.push(NULL);
                if(node->right) sta.push(node->right);
                if(node->left) sta.push(node->left);
            }
            else
            {
                node = sta.top();sta.pop();
                if(node==p) myP = node;
                if(node==q) myQ = node;
                
                if(myP!=NULL)
                {
                    if(node->left==myP||node->right==myP) myP = node;
                }
                if(myQ!=NULL)
                {
                    if(node->left==myQ||node->right==myQ) myQ = node;
                }
                if(myP!=NULL&&myQ!=NULL&&myP==myQ) return myP;
            }
        }
        return NULL;
    }
};
~~~

