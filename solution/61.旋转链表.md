# 61.旋转链表

## 题目描述

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`



## 题解

完美题解

~~~
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head==nullptr) return head;
        int nodeNum = 1;
        ListNode* curr = head;
        while(curr->next)
        {
            nodeNum++;
            curr = curr->next;
        }
        //cout<<nodeNum<<endl;
        ListNode* temp = curr;
        k = k%nodeNum;
        nodeNum-=k;
        curr = head;
        while(nodeNum>1)
        {
            curr = curr->next;
            nodeNum--;
            //cout<<"test"<<endl;
        }
        //cout<<curr->val<<endl;
        ListNode* result = curr->next;
        if(result==nullptr) return head;
        curr->next = nullptr;
        temp->next = head;
        return result;
    }
};
~~~

