# 1192. Tarjan算法 查找集群内的关键连接

## question

力扣数据中心有 `n` 台服务器，分别按从 `0` 到 `n-1` 的方式进行了编号。它们之间以 **服务器到服务器** 的形式相互连接组成了一个内部集群，连接是无向的。用  `connections` 表示集群网络，`connections[i] = [a, b]` 表示服务器 `a` 和 `b` 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。

**关键连接** 是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。

请你以任意顺序返回该集群内的所有 **关键连接** 。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png)**

```
输入：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
输出：[[1,3]]
解释：[[3,1]] 也是正确的。
```

**示例 2:**

```
输入：n = 2, connections = [[0,1]]
输出：[[0,1]]
```

 

**提示：**

- `2 <= n <= 105`
- `n - 1 <= connections.length <= 105`
- `0 <= ai, bi <= n - 1`
- `ai != bi`
- 不存在重复的连接



## solution

tarjan算法板子题

~~~
class Solution {
public:
    int num = 0;//为时间戳编号的一个编号器
    vector<int> dfn;//节点的时间戳（即第一次访问该节点的时间）
    vector<int> low;//节点的追溯值：节点可达的最早时间戳点
    vector<vector<int>> result;//记录答案
    vector<vector<int>> adj;// 邻接表
    void tarjan(int u, int fa) // fa是u的父节点
    {
        dfn[u] = low[u] = ++num;
        for(int v:adj[u])
        {
            if(v==fa) continue;
            if(!dfn[v]){//相邻节点未访问
                tarjan(v,u);
                low[u] = min(low[u],low[v]);
                if(dfn[u]<low[v]) result.push_back({u,v});
                //如果u的相邻节点v无法通过其他路径追溯到u，说明uv之间只有一条可达路径
            }
            else {
                low[u] = min(low[u],dfn[v]);
            }
        }
    }
    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        dfn.resize(n);
        low.resize(n);
        adj.resize(n);
        for(auto edge : connections)
        {
            //邻接表存图
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
        for(int u=0;u<n;u++)
        {
            if(!dfn[u]) tarjan(u,-1); // Tarjan 更新以u为根的搜索树。-1表示根节点无父节点
        }
        return result;
    }
};
~~~

下面我将为您详细讲解这段基于 Tarjan 算法求解无向图中关键连接（即“桥”）的 C++ 代码逻辑。代码的核心是使用深度优先搜索（DFS）结合时间戳（`dfn`）和追溯值（`low`）来识别那些一旦移除会导致图不连通的边。

### 🔍 代码整体思路

这道题要求找出无向图中的所有关键连接，即“桥”。桥是指一条边，如果移除它，原连通图会变得不连通的边。Tarjan 算法通过一次DFS遍历即可高效解决此问题，其核心思想是：**如果一条边 (u, v) 是桥，那么从节点 v 出发无法通过非父节点的回边追溯到 u 或其更早的祖先**。算法通过比较节点 v 的追溯值 `low[v]`和节点 u 的发现时间 `dfn[u]`来判断（条件为 `low[v] > dfn[u]`）。

### ⚙️ 关键变量与初始化

在 `criticalConnections`主函数中，代码首先初始化了几个关键的数据结构：

- **`dfn`向量**：记录每个节点在DFS中被首次访问的顺序（时间戳）。初始值通常为0，表示未访问。
- **`low`向量**：记录每个节点通过其子树中的回边能够追溯到的**最早祖先节点的时间戳**。初始值与 `dfn`相同。
- **`num`变量**：全局时间戳计数器，每访问一个新节点就递增，用于分配 `dfn`和 `low`的初始值。
- **`adj`向量**：图的邻接表存储结构。根据输入的双向边构建，使得每个节点都能直接访问其所有邻居。
- **`result`向量**：用于存储最终找到的所有关键连接（桥）。

初始化后，代码对每个未访问的节点调用 `tarjan(u, -1)`函数，其中 `-1`表示根节点没有父节点。

### 🔄 Tarjan 递归函数详解

`tarjan(int u, int fa)`函数是算法的核心，其逻辑如下列流程图所示，它通过DFS遍历、状态更新和条件判断来识别桥边：

```
flowchart TD
    A[开始tarjan递归] --> B{当前节点u是否已访问?}
    B -- 否 --> C[标记u的dfn和low<br>为++num]
    C --> D[遍历u的每个邻居v]
    D --> E{v是父节点fa?}
    E -- 是 --> F[跳过，处理下一个邻居]
    E -- 否 --> G{v未被访问过?}
    G -- 是 --> H[递归调用tarjan]
    H --> I[更新low[u] = min low[u], low[v]
    I --> J{检查low[v] > dfn[u]?}
    J -- 是 --> K[边 u-v 是桥，加入result]
    J -- 否 --> F
    G -- 否 --> L[更新low[u] = min low[u], dfn[v]
    L --> F
    F --> M{还有未处理邻居?}
    M -- 是 --> D
    M -- 否 --> N[当前节点处理完毕]
```

具体来说，递归过程中的关键操作包括：

1. **标记当前节点**：当首次访问节点 `u`时，记录其 `dfn[u]`和 `low[u]`为当前时间戳 `++num`。
2. **遍历邻居节点**：对于 `u`的每个邻居 `v`： 如果 `v`是父节点 `fa`，则跳过（避免回溯）。 如果 `v`未被访问过（`!dfn[v]`），则递归调用 `tarjan(v, u)`。递归返回后，用 `v`的追溯值 `low[v]`更新 `u`的追溯值：`low[u] = min(low[u], low[v])`。紧接着**判断桥的条件**：如果 `low[v] > dfn[u]`，说明从 `v`出发无法通过回边到达 `u`或其祖先，因此边 `(u, v)`是桥，将其加入 `result`。 如果 `v`已被访问过且不是父节点，说明 `(u, v)`是一条回边。此时用 `v`的发现时间 `dfn[v]`来更新 `u`的追溯值：`low[u] = min(low[u], dfn[v])`。这里使用 `dfn[v]`而非 `low[v]`的原因在于，回边直接指向 `v`，而 `v`的 `low`值可能指向更早的祖先，但当前回边只能追溯到 `v`本身的时间戳。

### 💡 核心判断逻辑：为何 `low[v] > dfn[u]`标识桥？

这个条件是算法的关键。`dfn[u]`是节点 `u`被访问的固定时间点。`low[v]`代表从 `v`出发能回到的“最早”时间戳节点。

- 如果 `low[v] > dfn[u]`，意味着 `v`及其后代**只能**通过边 `(u, v)`连接到 `u`，而没有其他路径（回边）能通到 `u`或其祖先。因此，移除边 `(u, v)`后，`v`所在的子图将与主图断开，该边即为桥。
- 如果 `low[v] <= dfn[u]`，则说明 `v`存在另一条路径能到达 `u`或其祖先（即存在环），边 `(u, v)`就不是桥。

### ⏱️ 算法复杂度

- **时间复杂度**：O(V + E)，其中 V 是节点数，E 是边数。每个节点和每条边在DFS过程中都只被处理一次。
- **空间复杂度**：O(V + E)，主要用于存储邻接表 `adj`和DFS递归栈。

### 🌰 简单示例

以示例 `n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]`为例（节点0、1、2构成环，节点3通过节点1连接）：

- 边 `(1,3)`满足 `low[3] > dfn[1]`（假设从节点0开始DFS，时间戳递增），因此被识别为关键连接。而环中的边（如 `(0,1)`、`(1,2)`、`(2,0)`）因 `low`值在环内被更新得更小，不满足桥的条件。

### 💎 总结

这段代码通过Tarjan算法高效地找出了无向图中的所有桥。其核心在于利用DFS遍历、时间戳 `dfn`和追溯值 `low`的维护与更新，以及最终的关键条件判断 `low[v] > dfn[u]`。该算法只需一次遍历，非常适合处理大规模图数据。