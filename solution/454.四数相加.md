# 454.四数相加

## 题目描述

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

 

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**示例 2：**

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

## 题解

沟槽的，我先写了个n^4^ 果不其然超时了，又写了个反正大于n^2^的也超时了。最后只能扫了一眼标准答案看了下思路要用unordered_map比较好，key存值，value存出现次数。虽然前两次自己写的没能通过，但是也给自己提供了相当多的思路。瞄了一眼提示结合之前失败的经验就果然通过了。通过的算法时间复杂度是O(n^2^)

~~~
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> result_map1;
        unordered_map<int,int> result_map2;
        int result = 0;
        int size = nums1.size();
        for(int i=0;i<size;i++)
        {
            for(int j=0;j<size;j++)
            {
                int temp = nums1[i]+nums2[j];
                auto it = result_map1.find(temp);
                if(it == result_map1.end()) 
                    result_map1.insert(make_pair(temp,1));
                else it->second++;
            }
        }
        for(int i=0;i<size;i++)
        {
            for(int j=0;j<size;j++)
            {
                int temp = nums3[i]+nums4[j];
                auto it = result_map2.find(temp);
                if(it == result_map2.end()) 
                    result_map2.insert(make_pair(temp,1));
                else it->second++;
            }
        }
        for(auto it = result_map1.begin();it!=result_map1.end();it++)
        {
            auto it2 = result_map2.find(0-it->first);
            if(it2 != result_map2.end())
                result += it2->second * it->second;
        }
        return result;

    }
};
~~~

尽管思路与标准答案相似，但是人家明显更加简洁，需要的空间复杂度也更小。

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {
            for (int b : B) {
                umap[a + b]++;
            }
        }
        int count = 0; // 统计a+b+c+d = 0 出现的次数
        // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)];
                }
            }
        }
        return count;
    }
};
```