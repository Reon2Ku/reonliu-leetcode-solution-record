# 33.搜索旋转排序数组

## 题目描述

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 向左旋转 `3` 次后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

 

**提示：**

- `1 <= nums.length <= 5000`
- `-104 <= nums[i] <= 104`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-104 <= target <= 104`



## 题解

摆烂解法：

~~~
class Solution {
public:
    int search(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]==target) return i;
        }
        return -1;
    }
};
~~~

正经解法：

~~~
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size()==1)
        {
            if(nums[0]==target) return 0;
            else return -1;
        }
        int left = 0;
        int right = nums.size()-1;
        if(nums[0]>nums[nums.size()-1])
        {
            int max = -1;
            while(right>left)
            {
                if(nums[left+1]<nums[left] || nums[right-1]>nums[right])
                {
                    if(nums[left+1]<nums[left]) max = left;
                    else if(nums[right-1]>nums[right]) max = right-1;
                    break;
                } 
                int mid = (right+left)/2;
                if(nums[mid]>nums[left]) left = mid;
                else if(nums[mid]<nums[right]) right = mid;
            }
            cout<<max<<endl;
            if(target>nums[max] || target<nums[max+1] || (target>nums[nums.size()-1]&&target<nums[0])) return -1;
            if(target>=nums[0]) 
            {
                left = 0;
                right = max;
            }
            else if(target<=nums[nums.size()-1])
            {
                left = max+1;
                right = nums.size()-1;
            }
            cout<<left<<" "<<right<<endl;
        }
        
        while(right>left)
        {
            int mid = (right+left)/2;
            if(nums[mid]==target) return mid;
            else if(mid==left || mid==right) break;
            else if(nums[mid]>target) right = mid;
            else if(nums[mid]<target) left = mid;
        }
        if(target==nums[left]) return left;
        if(target==nums[right]) return right;
        return -1;
    }
};
~~~

