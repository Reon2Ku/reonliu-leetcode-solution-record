# 2483. Minimum Penalty for a shop

## question

You are given the customer visit log of a shop represented by a **0-indexed** string `customers` consisting only of characters `'N'` and `'Y'`:

- if the `ith` character is `'Y'`, it means that customers come at the `ith` hour
- whereas `'N'` indicates that no customers come at the `ith` hour.

If the shop closes at the `jth` hour (`0 <= j <= n`), the **penalty** is calculated as follows:

- For every hour when the shop is open and no customers come, the penalty increases by `1`.
- For every hour when the shop is closed and customers come, the penalty increases by `1`.

Return *the **earliest** hour at which the shop must be closed to incur a **minimum** penalty.*

**Note** that if a shop closes at the `jth` hour, it means the shop is closed at the hour `j`.

 

**Example 1:**

```
Input: customers = "YYNY"
Output: 2
Explanation: 
- Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.
- Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.
- Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.
- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.
- Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.
Closing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.
```

**Example 2:**

```
Input: customers = "NNNNN"
Output: 0
Explanation: It is best to close the shop at the 0th hour as no customers arrive.
```

**Example 3:**

```
Input: customers = "YYYY"
Output: 4
Explanation: It is best to close the shop at the 4th hour as customers arrive at each hour.
```

 

**Constraints:**

- `1 <= customers.length <= 105`
- `customers` consists only of characters `'Y'` and `'N'`.



## solution

时空击败10%有点搞笑

~~~
class Solution {
public:
    int bestClosingTime(string customers) {
        vector<vector<int>> vec(2,vector<int>(customers.size()+1,0));
        //0 repre 0, 1 repre 1
        for(int i=1;i<vec[0].size();i++)
        {
            if(customers[i-1]=='N') vec[0][i] = vec[0][i-1]+1;
            else vec[0][i] = vec[0][i-1];
        }
        for(int i=customers.size();i>0;i--)
        {
            if(customers[i-1]=='Y') vec[1][i-1] = vec[1][i]+1;
            else vec[1][i-1] = vec[1][i];
        }
        int sum = INT_MAX;
        int index = 0;
        // for(int i=0;i<vec[0].size();i++)
        // {
        //     cout<<"Y after:"<<vec[1][i]<<" N before:"<<vec[0][i]<<endl;
        // }
        for(int i=0;i<vec[0].size();i++)
        {
            if(vec[0][i]+vec[1][i]<sum) 
            {
                sum = vec[0][i]+vec[1][i];
                index = i;
            }
        }
        return index;
    }
};
~~~

挺奇怪的，尽管空间击败了94%，时间却只击败26%

~~~
class Solution {
public:
    int bestClosingTime(string customers) {
        int countN = 0;
        int countY = 0;
        for(char c:customers)
        {
            if(c=='Y') countY++;
        }
        int sum = countY;
        int index = 0;
        for(int i=0;i<customers.size();i++)
        {
            if(customers[i]=='Y')
            {
                countY--;
                if(countY+countN<sum)
                {
                    sum = countN+countY;
                    index = i+1;
                }
            }
            else countN++;
        }
        return index;
    }
};
~~~

好了，这是击败双百的解法：虽然小瞟了一眼评论大神思路，但是我已经尽量做到最好了。因为本题中只需要最终的index，所以YN数量是无所谓的。

~~~
class Solution {
public:
    int bestClosingTime(string customers) {
        int index = 0;
        int sum = 0;
        int minSum = 0;
        for(int i=0;i<customers.size();i++)
        {
            if(customers[i]=='Y')
            {
                sum--;
            }
            else sum++;
            if(sum<minSum) 
            {
                minSum = sum;
                index = i+1;
            }
            //cout<<index<<endl;
        }
        return index;
    }
};
~~~

