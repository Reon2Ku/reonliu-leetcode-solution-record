# 94.二叉树的中序遍历

## 题目描述

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

## 题解

递归法：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inTraversal(TreeNode* curr, vector<int>& vec)
    {
        if(curr==nullptr) return;
        inTraversal(curr->left,vec);
        vec.push_back(curr->val);
        inTraversal(curr->right,vec);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        inTraversal(root,result);
        return result;
    }
};
~~~

迭代法：技巧性疑似有点太强了。。。

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> myStack;
        vector<int> result;
        if(root==NULL) return result;
        TreeNode* curr = root;
        while(!myStack.empty()||curr != NULL)
        {
            if(curr!=NULL)
            {
                myStack.push(curr);
                curr = curr->left;  
            }
            else
            {
                curr = myStack.top();
                result.push_back(curr->val);
                myStack.pop();
                curr = curr->right;
            }
        }
        return result;
    }
};
~~~

为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：

1. **处理：将元素放进result数组中**
2. **访问：遍历节点**

分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

动画如下：

![二叉树中序遍历（迭代法）](https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)



然而这种迭代法技巧性太强了，有没有什么逻辑性又强又不需要很强技巧性的迭代法呢？

来看统一风格迭代法

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> sta;
        if(root==NULL) return result;
        sta.push(root);
        while(!sta.empty())
        {
            TreeNode* node = sta.top();
            if(node!=NULL)
            {
                sta.pop();
                if(node->right) sta.push(node->right);

                sta.push(node);
                sta.push(NULL);//标记node节点，表示已访问但未添加到result数组

                if(node->left) sta.push(node->left);
            }
            else
            {
                sta.pop();
                node = sta.top();
                result.push_back(node->val);
                sta.pop();
            }
        }
        return result;
    }
};
~~~

从根节点开始，我们既希望利用这个根节点访问到他的左右子节点（如果有的话），有希望最后能够将其放入result集中正确的位置。所以我们一开始将根节点放入栈中之后要做几件事：①把他取出来②把他的右孩子放进栈③把他自己放进栈④加入一个null节点表示我们已经使用这个root访问过了左右子节点⑤把他的左孩子放入栈。

如此一来我们就形成了一个右中左的栈，先进后出的原则会将输出结果顺序颠倒变为左中右实现中序遍历

以中序遍历为例，我们需要在前序遍历中做的事（构建右左中，颠倒后变为中左右）以及后序遍历中做的事（构建中右左，颠倒后变为左右中）其实是类似的，可以像递归法中仅更改代码中少量代码的顺序即可实现。