# 501.二叉搜索树中的众数（指定sort排序规则）

## 题目描述

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg)

```
输入：root = [1,null,2,2]
输出：[2]
```

**示例 2：**

```
输入：root = [0]
输出：[0]
```

## 题解

自己写的幽默解，打败5%。难绷，代码随想录给出的第一种解法也是这个。但是，这种解法更适用于一般的二叉树中找众数，用这种方法我们没能很好的利用到二叉搜索树的性质。

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int,int> myMap;
    void myFind(TreeNode* root)
    {
        if(root==NULL) return;
        if(root->left) myFind(root->left);
        auto it = myMap.find(root->val);
        if(it==myMap.end()) myMap.insert(make_pair(root->val,1));
        else if(it!=myMap.end()) it->second++;
        if(root->right) myFind(root->right);
    }
    vector<int> findMode(TreeNode* root) {
        myFind(root);
        vector<pair<int,int>> temp(myMap.begin(),myMap.end()); 
        vector<int> result;
        sort(temp.begin(),temp.end(),[](const pair<int,int>& a,const pair<int,int>& b){
            return a.second>b.second;
        });
        int count=1;
        result.push_back(temp[0].first);
        for(;count<temp.size();count++)
        {
            if(temp.size()==1)  break;
            else if(temp[count].second==temp[count-1].second) result.push_back(temp[count].first);
            else break;
        }
        return result;
    }
};

//或者也可以这么写sort逻辑：
//bool static compare(const pair<int,int>& a,const pair<int,int>& b)
//{
//	return a.second>b.second; 
//}

//sort(vec.begin(),vec.end(),compare);
~~~

沟槽的动不动就依赖标准答案，自己只敲出个大概的模板，照着标准答案改了不少

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxCount = 1;
    int count = 1;
    TreeNode* pre = NULL;
    vector<int> result;
    void inOrder(TreeNode* root)
    {
        if(root==NULL) return;
        if(root->left) inOrder(root->left);

        if(pre!=NULL&&root->val == pre->val) count++;
        else if(pre!=NULL&&root->val!=pre->val) count = 1;

        if(count==maxCount) result.push_back(root->val);
        else if(count>maxCount) 
        {
            while(result.begin()!=result.end()) result.pop_back();
            //result.clear();就可以了，不要用while循环清除
            result.push_back(root->val);
        }
        maxCount = max(count,maxCount);
        pre = root;
        if(root->right) inOrder(root->right);
        
    }
    vector<int> findMode(TreeNode* root) {
        inOrder(root);
        return result;
    }
};
~~~

自己延续上述思路又写了一遍：

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*> sta;
        vector<int> result;
        if(root==NULL) return result;
        sta.push(root);
        int maxCount = 1;
        int count = 1;
        TreeNode* pre = NULL;
        while(!sta.empty()) 
        {
            TreeNode* node = sta.top();sta.pop();
            if(node!=NULL)
            {
                if(node->right) sta.push(node->right);
                sta.push(node);
                sta.push(NULL);
                if(node->left) sta.push(node->left);
            }
            else
            {
                node = sta.top();
                if(pre!=NULL&&node->val==pre->val) count++;
                else if(pre!=NULL&&node->val!=pre->val) count=1;

                if(count==maxCount) result.push_back(node->val);
                else if(count>maxCount)
                {
                    while(result.begin()!=result.end()) result.pop_back();
                    //result.clear()就可以了，不要用while循环清除;
                    result.push_back(node->val);
                    maxCount = count;
                }
                sta.pop();
                pre = node;
            }
        }
        return result;
    }
};
~~~

