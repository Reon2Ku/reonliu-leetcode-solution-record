# 298. Binary Tree Longest Consecutive Sequence

Given the `root` of a binary tree, return *the length of the longest **consecutive sequence path***.

A **consecutive sequence path** is a path where the values **increase by one** along the path.

Note that the path can start **at any node** in the tree, and you cannot go from a node to its parent in the path.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg)

```
Input: root = [1,null,3,2,4,null,null,null,5]
Output: 3
Explanation: Longest consecutive sequence path is 3-4-5, so return 3.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg)

```
Input: root = [2,null,3,2,null,1]
Output: 2
Explanation: Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 3 * 104]`.
- `-3 * 104 <= Node.val <= 3 * 104`



## solution

虽然时间空间都不咋样但是光是想出解就辛苦我了

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int searchConsecutive(TreeNode* node,int& result)
    {
        int leftmax = 1;
        int rightmax = 1;
        if(!node->left && !node->right) return 1;
        if(!node->left) 
        {
            rightmax = searchConsecutive(node->right,result);
            if(node->val+1==node->right->val) rightmax++;
            else rightmax=1;
        }
        else if(!node->right)
        {
            leftmax = searchConsecutive(node->left,result);
            if(node->val+1==node->left->val) leftmax++;
            else leftmax=1;
        }
        else 
        {
            leftmax = searchConsecutive(node->left,result);
            rightmax = searchConsecutive(node->right,result);
            if(node->val+1==node->right->val) rightmax++;
            else rightmax=1;
            if(node->val+1==node->left->val) leftmax++;
            else leftmax=1;
        }
        result = max(result,max(leftmax,rightmax));
        return max(leftmax,rightmax);
    }
    int longestConsecutive(TreeNode* root) {
        int result = 1;
        searchConsecutive(root,result);
        return result;
    }
};
~~~

你的代码冗余部分太多了，完全可以精简一些的

~~~
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int searchConsecutive(TreeNode* node,int& result)
    {
        if(node==nullptr) return 0;
        if(!node->left && !node->right) return 1;
        int currentLength = 1;
        int leftmax = searchConsecutive(node->left,result);
        int rightmax = searchConsecutive(node->right,result);
        if(node->left && node->left->val-1==node->val)
        {
            currentLength = max(leftmax+1,currentLength);
        }
        if(node->right && node->right->val-1==node->val)
        {
            currentLength = max(rightmax+1,currentLength);
        }
        result = max(result,currentLength);
        return currentLength;
    }
    int longestConsecutive(TreeNode* root) {
        int result = 1;
        searchConsecutive(root,result);
        return result;
    }
};
~~~

