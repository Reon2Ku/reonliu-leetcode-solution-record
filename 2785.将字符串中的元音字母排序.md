# 2785.将字符串中的元音字母排序

## 题目描述

Given a **0-indexed** string `s`, **permute** `s` to get a new string `t` such that:

- All consonants remain in their original places. More formally, if there is an index `i` with `0 <= i < s.length` such that `s[i]` is a consonant, then `t[i] = s[i]`.
- The vowels must be sorted in the **nondecreasing** order of their **ASCII** values. More formally, for pairs of indices `i`, `j` with `0 <= i < j < s.length` such that `s[i]` and `s[j]` are vowels, then `t[i]` must not have a higher ASCII value than `t[j]`.

Return *the resulting string*.

The vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.

 

**Example 1:**

```
Input: s = "lEetcOde"
Output: "lEOtcede"
Explanation: 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd' are all consonants. The vowels are sorted according to their ASCII values, and the consonants remain in the same places.
```

**Example 2:**

```
Input: s = "lYmpH"
Output: "lYmpH"
Explanation: There are no vowels in s (all characters in s are consonants), so we return "lYmpH".
```

 

**Constraints:**

- `1 <= s.length <= 105`
- `s` consists only of letters of the English alphabet in **uppercase and lowercase**.



## solution

我用了两种方法，空间开销似乎都挺大的。应该是有更好的办法去做

~~~
class Solution {
public:
    string sortVowels(string s) {
        // vector<bool> lowercase(26,0);
        // vector<bool> uppercase(26,0);
        // lowercase['a'-'a'] = 1;
        // lowercase['e'-'a'] = 1;
        // lowercase['i'-'a'] = 1;
        // lowercase['o'-'a'] = 1;
        // lowercase['u'-'a'] = 1;
        // uppercase['A'-'A'] = 1;
        // uppercase['E'-'A'] = 1;
        // uppercase['I'-'A'] = 1;
        // uppercase['O'-'A'] = 1;
        // uppercase['U'-'A'] = 1;

        vector<int> recordIndex;
        vector<char> recordCharacter;
        for(int i=0;i<s.size();i++)
        {
            bool flag = (s[i]-'a')&&(s[i]-'e')&&(s[i]-'i')&&(s[i]-'o')&&(s[i]-'u')&&(s[i]-'A')&&(s[i]-'E')&&(s[i]-'I')&&(s[i]-'O')&&(s[i]-'U');
            //if((s[i]-'a'>=0 && lowercase[s[i]-'a']) || (s[i]-'a'<0 && uppercase[s[i]-'A']))
            if(!flag)
            {
                recordCharacter.push_back(s[i]);
                recordIndex.push_back(i);
            }
        }
        // for(int i=0;i<recordCharacter.size();i++)
        //     cout<<recordCharacter[i];
        // cout<<endl;
        sort(recordCharacter.begin(),recordCharacter.end());
        // for(int i=0;i<recordCharacter.size();i++)
        //     cout<<recordCharacter[i];
        // cout<<endl;
        for(int i=0;i<recordIndex.size();i++)
        {
            s[recordIndex[i]] = recordCharacter[i];
        }
        return s;
    }
};
~~~

现在给你展示更好的方法：

来自leetcode官方题解。

注意，不仅可以对vector使用sort进行排序，string也是可以的，并且不需要想你这样去构建这么多的哈希表

不过根据提交结果来看，如下这种方法依旧还是同样的思路，先将元音字母提出来，随后排序好后再传回去。时间复杂度和空间复杂度上并没有颠覆性的优化。不过其解题思路和代码习惯依旧有值得学习的地方。

~~~
class Solution {
    unordered_set<char> vowels = {'a','e','i','o','u','A','E','I','O','U',};//以后涉及哈希表的题目请主动去使用unordered_set
public:
    string sortVowels(string s) {
        string temp;
        for(char c : s)
        {
            if(vowels.contains(c)) {
                temp.push_back(c);
            }
        }
        sort(temp.begin(),temp.end());
        int index = 0;
        for(char& c:s)//为了直接修改c，需要使用引用传入。否则c只不过是一个拷贝副本，修改拷贝副本没办法同时修改原处char
        {
            if(vowels.contains(c))
            {
                c = temp[index++];
            }
        }
        return s;

    }
};
~~~

仔细阅读官方题解后，我发现你最初的方法其实已经算比较可取的方法了。唯一的问题是在空间复杂度上可以做文章做优化，但也依旧难以跳脱出O(n)数量级的复杂度。

可以简单给你说下leetcode官方题解中的最后一种方法的思路，是在对sort函数做优化，因为sort一定是需要nlogn数量级的时间复杂度。可以直接使用哈希表，记录每个元音分别有多少个，再按顺序取就行了。

