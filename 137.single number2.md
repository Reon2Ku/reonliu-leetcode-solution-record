

# 137.single number2

## question

Given an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. *Find the single element and return it*.

You must implement a solution with a linear runtime complexity and use only constant extra space.

 

**Example 1:**

```
Input: nums = [2,2,3,2]
Output: 3
```

**Example 2:**

```
Input: nums = [0,1,0,1,0,1,99]
Output: 99
```

 

**Constraints:**

- `1 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- Each element in `nums` appears exactly **three times** except for one element which appears **once**.



## solution

暴力解

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        for(int i=2;i<nums.size();i+=3)
        {
            if(nums[i]!=nums[i-2]) return nums[i-2];
        }
        return nums[nums.size()-1];
    }
};
~~~

哈希表（依旧暴力解，练习map容器来的）

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        map<int,int> myMap;
        for(int i:nums)
        {
            if(myMap.find(i)==myMap.end())
            {
                myMap.insert({i,1});
            }
            else myMap[i]++;
        }
        for(auto it:myMap)
        {
            if(it.second == 1) return it.first;
        }
        return -1;
    }
};
~~~

这里学习一下另外一种map的遍历方法

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> myMap;
        for(int i:nums)
        {
            if(myMap.find(i)==myMap.end())
            {
                myMap.insert({i,1});
            }
            else myMap[i]++;
        }
        for(auto [num,occ]:myMap)
        {
            if(occ == 1) return num;
        }
        return -1;
    }
};
~~~

map和unordered_map的区别：

- **求极致查询速度** → 选 `unordered_map`（平均 O(1)），时间优势
- **需有序性/范围查询/稳定内存** → 选 `map`（稳定 O(log n)），空间优势

大神解法，我纯copy的：

~~~
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
};
~~~

### **表达式解析**

1. **`1 << i`**将数字 `1`（二进制 `0000 0001`）左移 `i`位，生成一个仅第 `i`位为 `1`的掩码。例如：`i = 2`→ `1 << 2 = 0000 0100`（十进制 `4`）`i = 5`→ `1 << 5 = 0010 0000`（十进制 `32`）
2. **`ans |= mask`**将 `ans`与掩码进行按位或运算（`ans | mask`），并将结果赋值给 `ans`。按位或规则：**只要某位为 `1`，结果位即为 `1`**。效果：无论 `ans`的第 `i`位原值如何，运算后该位必为 `1`；其他位不变

因为所有数字都出现了三次，具体到某一位上来说，这个数字要么贡献了3个1要么贡献3个0。而单独的那个数字也是要么贡献1要么贡献0。当singlenumber在某一位上为0时，total%3 = 0， 所以answer在这一位上也为0，不需要更新。当single number在某一位上为1时，total%3=1， 于是使用ans |= (1 << i);来将对应的位变为1.遍历int在二进制下可能有的32位，可以计算出answer

复杂度分析

时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围，在本题中 logC=log2 
32
 =32，也就是我们需要遍历第 0∼31 个二进制位。

空间复杂度：O(1)。

a<<b将b左移a位

b>>a将b右移a位