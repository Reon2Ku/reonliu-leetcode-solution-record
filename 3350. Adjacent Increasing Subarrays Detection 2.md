# 3350. Adjacent Increasing Subarrays Detection 2

## question

Given an array `nums` of `n` integers, your task is to find the **maximum** value of `k` for which there exist **two** adjacent subarrays of length `k` each, such that both subarrays are **strictly** **increasing**. Specifically, check if there are **two** subarrays of length `k` starting at indices `a` and `b` (`a < b`), where:

- Both subarrays `nums[a..a + k - 1]` and `nums[b..b + k - 1]` are **strictly increasing**.
- The subarrays must be **adjacent**, meaning `b = a + k`.

Return the **maximum** *possible* value of `k`.

A **subarray** is a contiguous **non-empty** sequence of elements within an array.

 

**Example 1:**

**Input:** nums = [2,5,7,8,9,2,3,4,3,1]

**Output:** 3

**Explanation:**

- The subarray starting at index 2 is `[7, 8, 9]`, which is strictly increasing.
- The subarray starting at index 5 is `[2, 3, 4]`, which is also strictly increasing.
- These two subarrays are adjacent, and 3 is the **maximum** possible value of `k` for which two such adjacent strictly increasing subarrays exist.

**Example 2:**

**Input:** nums = [1,2,3,4,4,4,4,5,6,7]

**Output:** 2

**Explanation:**

- The subarray starting at index 0 is `[1, 2]`, which is strictly increasing.
- The subarray starting at index 2 is `[3, 4]`, which is also strictly increasing.
- These two subarrays are adjacent, and 2 is the **maximum** possible value of `k` for which two such adjacent strictly increasing subarrays exist.

 

**Constraints:**

- `2 <= nums.length <= 2 * 105`
- `-109 <= nums[i] <= 109`



## solution

初见：

![image-20251014202019501](C:\Users\Reon\AppData\Roaming\Typora\typora-user-images\image-20251014202019501.png)

~~~
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> dp(nums.size(),1);
        //cout<<dp[0]<<endl;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1;
            //cout<<dp[i]<<endl;
        }
        int count = 0;
        for(int i=0;i<nums.size()-1;i++)
        {
            if(dp[i]>=dp[i+1]) 
            {
                nums[count] = dp[i];
                count++;
            }
        }
        nums[count] = dp[nums.size()-1];
        count++;
        nums.resize(count);
        //cout<<":-------------"<<endl;
        int result = 1;
        for(int i=0;i<nums.size()-1;i++)
        {
            //cout<<nums[i]<<endl;
            result = max(result,nums[i]/2);
            result = max(result,min(nums[i],nums[i+1]));
        }
        result = max(result,nums[count-1]/2);
        //cout<<nums[nums.size()-1];
        return result;
    }
};
~~~

优化后：

![image-20251014202854121](C:\Users\Reon\AppData\Roaming\Typora\typora-user-images\image-20251014202854121.png)

~~~
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> dp;
        int count = 1;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]>nums[i-1]) count++;
            else
            {
                dp.push_back(count);
                //cout<<count<<endl;
                count = 1;
            }
        }
        dp.push_back(count);
        //cout<<count<<endl;
        count = 1;
        for(int i=0;i<dp.size()-1;i++)
        {
            //cout<<nums[i]<<endl;
            count = max(count,dp[i]/2);
            count = max(count,min(dp[i],dp[i+1]));
        }
        count = max(count,dp[dp.size()-1]/2);
        //cout<<nums[nums.size()-1];
        return count;
    }
};
~~~

再优化

![image-20251014203334277](C:\Users\Reon\AppData\Roaming\Typora\typora-user-images\image-20251014203334277.png)

~~~
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        //vector<int> dp;
        int result = 1;
        int count = 1;
        int front = 1;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]>nums[i-1]) count++;
            else
            {
                result = max(result,count/2);
                result = max(result,min(front,count));
                front = count;
                count = 1;
            }
        }
        result = max(result,count/2);
        result = max(result,min(front,count));
        return result;
    }
};
~~~

最牛逼最简洁的解：来自力扣大神。可以看到我的思路已经非常接近他了，只是人家把内存开销节省到了极致， 使用一个j下标玩弄索引就求出了所有解

~~~
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
                
        int n = nums.size(), res = 0;
        for (int i = 0, j = 0, l = 0; i < n; )
        {
            while (j + 1 < n && nums[j + 1] > nums[j])
                ++j;
            res = max({ res, min(l, j - i + 1), j - i + 1 >> 1 });
            l = j - i + 1;
            i = ++j;
        }

        return res;
    }
};
~~~

